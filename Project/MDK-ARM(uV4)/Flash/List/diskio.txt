; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\diskio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\FatFS\src -I..\..\User\usbh_mass_storage -ID:\Software\keil\ARM\RV31\INC -ID:\Software\keil\ARM\CMSIS\Include -ID:\Software\keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=518 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\diskio.crf ..\..\User\FatFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=2

                  disk_initialize PROC
;;;19     
;;;20     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;21     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;22     )
;;;23     {
000002  4604              MOV      r4,r0
;;;24     	DSTATUS stat = STA_NOINIT;
000004  2501              MOVS     r5,#1
;;;25     
;;;26     	switch (pdrv)
000006  b934              CBNZ     r4,|L1.22|
;;;27     	{
;;;28     		case FS_USB :		/* STM32 USB Host 口外接U盘 */
;;;29     			if(HCD_IsDeviceConnected(&USB_OTG_Core))
000008  4805              LDR      r0,|L1.32|
00000a  f7fffffe          BL       HCD_IsDeviceConnected
00000e  b108              CBZ      r0,|L1.20|
;;;30     			{
;;;31     				stat &= ~STA_NOINIT;
000010  f0250501          BIC      r5,r5,#1
                  |L1.20|
;;;32     			}
;;;33     			break;
000014  e000              B        |L1.24|
                  |L1.22|
;;;34     
;;;35     		default :
;;;36     			break;
000016  bf00              NOP      
                  |L1.24|
000018  bf00              NOP                            ;33
;;;37     	}
;;;38     	return stat;
00001a  4628              MOV      r0,r5
;;;39     }
00001c  bd70              POP      {r4-r6,pc}
;;;40     
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      USB_OTG_Core

                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;185    #if _USE_IOCTL
;;;186    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;187    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;188    	BYTE cmd,		/* Control code */
;;;189    	void *buff		/* Buffer to send/receive control data */
;;;190    )
;;;191    {
000002  4603              MOV      r3,r0
;;;192    	DRESULT res;
;;;193    
;;;194    	switch (pdrv) {
000004  b9f3              CBNZ     r3,|L2.68|
;;;195    	case FS_USB :
;;;196    		{
;;;197    			//if (drv) return RES_PARERR;
;;;198    			res = RES_ERROR;
000006  2401              MOVS     r4,#1
;;;199    
;;;200    			//if (Stat & STA_NOINIT) return RES_NOTRDY;
;;;201    			switch (cmd)
000008  b131              CBZ      r1,|L2.24|
00000a  2901              CMP      r1,#1
00000c  d006              BEQ      |L2.28|
00000e  2902              CMP      r1,#2
000010  d009              BEQ      |L2.38|
000012  2903              CMP      r1,#3
000014  d111              BNE      |L2.58|
000016  e00b              B        |L2.48|
                  |L2.24|
;;;202    			{
;;;203    				case CTRL_SYNC :		/* Make sure that no pending write process */
;;;204    					res = RES_OK;
000018  2400              MOVS     r4,#0
;;;205    					break;
00001a  e010              B        |L2.62|
                  |L2.28|
;;;206    
;;;207    				case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;;;208    					*(DWORD*)buff = (DWORD) USBH_MSC_Param.MSCapacity;
00001c  480a              LDR      r0,|L2.72|
00001e  6800              LDR      r0,[r0,#0]  ; USBH_MSC_Param
000020  6010              STR      r0,[r2,#0]
;;;209    					res = RES_OK;
000022  2400              MOVS     r4,#0
;;;210    					break;
000024  e00b              B        |L2.62|
                  |L2.38|
;;;211    
;;;212    				case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
;;;213    					*(WORD*)buff = 512;
000026  f44f7000          MOV      r0,#0x200
00002a  8010              STRH     r0,[r2,#0]
;;;214    					res = RES_OK;
00002c  2400              MOVS     r4,#0
;;;215    					break;
00002e  e006              B        |L2.62|
                  |L2.48|
;;;216    
;;;217    				case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */\
;;;218    					*(DWORD*)buff = 512;
000030  f44f7000          MOV      r0,#0x200
000034  6010              STR      r0,[r2,#0]
;;;219    					res = RES_OK;
000036  2400              MOVS     r4,#0
;;;220    					break;
000038  e001              B        |L2.62|
                  |L2.58|
;;;221    
;;;222    				default:
;;;223    					res = RES_PARERR;
00003a  2404              MOVS     r4,#4
;;;224    					break;
00003c  bf00              NOP      
                  |L2.62|
00003e  bf00              NOP                            ;205
;;;225    			}
;;;226    			return res;
000040  4620              MOV      r0,r4
                  |L2.66|
;;;227    		}
;;;228    
;;;229    	}
;;;230    	return RES_PARERR;
;;;231    }
000042  bd10              POP      {r4,pc}
                  |L2.68|
000044  2004              MOVS     r0,#4                 ;230
000046  e7fc              B        |L2.66|
;;;232    #endif
                          ENDP

                  |L2.72|
                          DCD      USBH_MSC_Param

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;68     
;;;69     DRESULT disk_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;70     	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;71     	BYTE *buff,		/* Data buffer to store read data */
;;;72     	DWORD sector,	/* Sector address (LBA) */
;;;73     	BYTE count		/* Number of sectors to read (1..128) */
;;;74     )
;;;75     {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;76     	DRESULT res;
;;;77     
;;;78     	switch (pdrv)
00000c  b9ed              CBNZ     r5,|L3.74|
;;;79     	{
;;;80     		case FS_USB :
;;;81     			//res = USB_disk_read(buff, sector, count);
;;;82     			{
;;;83     				BYTE status = USBH_MSC_OK;
00000e  2700              MOVS     r7,#0
;;;84     
;;;85     				//if (Stat & STA_NOINIT) 	return RES_NOTRDY;
;;;86     
;;;87     				if (HCD_IsDeviceConnected(&USB_OTG_Core))
000010  4811              LDR      r0,|L3.88|
000012  f7fffffe          BL       HCD_IsDeviceConnected
000016  b198              CBZ      r0,|L3.64|
;;;88     				{
;;;89     					do
000018  bf00              NOP      
                  |L3.26|
;;;90     					{
;;;91     						status = USBH_MSC_Read10(&USB_OTG_Core, buff,sector,512 * count);
00001a  0273              LSLS     r3,r6,#9
00001c  464a              MOV      r2,r9
00001e  4641              MOV      r1,r8
000020  480d              LDR      r0,|L3.88|
000022  f7fffffe          BL       USBH_MSC_Read10
000026  4607              MOV      r7,r0
;;;92     						USBH_MSC_HandleBOTXfer(&USB_OTG_Core ,&USB_Host);
000028  490c              LDR      r1,|L3.92|
00002a  480b              LDR      r0,|L3.88|
00002c  f7fffffe          BL       USBH_MSC_HandleBOTXfer
;;;93     
;;;94     						if (!HCD_IsDeviceConnected(&USB_OTG_Core))
000030  4809              LDR      r0,|L3.88|
000032  f7fffffe          BL       HCD_IsDeviceConnected
000036  b900              CBNZ     r0,|L3.58|
;;;95     						{
;;;96     							break;
000038  e001              B        |L3.62|
                  |L3.58|
;;;97     						}
;;;98     					}
;;;99     					while (status == USBH_MSC_BUSY );
00003a  2f03              CMP      r7,#3
00003c  d0ed              BEQ      |L3.26|
                  |L3.62|
00003e  bf00              NOP                            ;96
                  |L3.64|
;;;100    				}
;;;101    
;;;102    				if (status == USBH_MSC_OK)
000040  b90f              CBNZ     r7,|L3.70|
;;;103    				{
;;;104    					res = RES_OK;
000042  2400              MOVS     r4,#0
000044  e000              B        |L3.72|
                  |L3.70|
;;;105    				}
;;;106    				else
;;;107    				{
;;;108    					res = RES_ERROR;
000046  2401              MOVS     r4,#1
                  |L3.72|
;;;109    				}
;;;110    			}
;;;111    			break;
000048  e001              B        |L3.78|
                  |L3.74|
;;;112    
;;;113    		default:
;;;114    			res = RES_PARERR;
00004a  2404              MOVS     r4,#4
;;;115    			break;
00004c  bf00              NOP      
                  |L3.78|
00004e  bf00              NOP                            ;111
;;;116    	}
;;;117    	return res;
000050  4620              MOV      r0,r4
;;;118    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;119    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      USB_OTG_Core
                  |L3.92|
                          DCD      USB_Host

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;46     
;;;47     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;48     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;49     )
;;;50     {
;;;51     	DSTATUS stat = STA_NOINIT;
000002  2001              MOVS     r0,#1
;;;52     
;;;53     	switch (pdrv)
000004  b909              CBNZ     r1,|L4.10|
;;;54     	{
;;;55     		case FS_USB :
;;;56     			stat = 0;
000006  2000              MOVS     r0,#0
;;;57     			break;
000008  e000              B        |L4.12|
                  |L4.10|
;;;58     
;;;59     		default:
;;;60     			break;
00000a  bf00              NOP      
                  |L4.12|
00000c  bf00              NOP                            ;57
;;;61     	}
;;;62     	return stat;
;;;63     }
00000e  4770              BX       lr
;;;64     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;123    #if _USE_WRITE
;;;124    DRESULT disk_write (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;125    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;126    	const BYTE *buff,	/* Data to be written */
;;;127    	DWORD sector,		/* Sector address (LBA) */
;;;128    	BYTE count			/* Number of sectors to write (1..128) */
;;;129    )
;;;130    {
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;131    	DRESULT res;
;;;132    
;;;133    	switch (pdrv)
00000c  b9ed              CBNZ     r5,|L5.74|
;;;134    	{
;;;135    		case FS_USB :
;;;136    			//res = USB_disk_write(buff, sector, count);
;;;137    			{
;;;138    				BYTE status = USBH_MSC_OK;
00000e  2700              MOVS     r7,#0
;;;139    
;;;140    				//if (drv || !count) return RES_PARERR;
;;;141    
;;;142    				//if (Stat & STA_NOINIT) return RES_NOTRDY;
;;;143    				//if (Stat & STA_PROTECT) return RES_WRPRT;
;;;144    
;;;145    				if (HCD_IsDeviceConnected(&USB_OTG_Core))
000010  4811              LDR      r0,|L5.88|
000012  f7fffffe          BL       HCD_IsDeviceConnected
000016  b198              CBZ      r0,|L5.64|
;;;146    				{
;;;147    					do
000018  bf00              NOP      
                  |L5.26|
;;;148    					{
;;;149    						status = USBH_MSC_Write10(&USB_OTG_Core,(BYTE*)buff,sector, 512 * count);
00001a  0273              LSLS     r3,r6,#9
00001c  464a              MOV      r2,r9
00001e  4641              MOV      r1,r8
000020  480d              LDR      r0,|L5.88|
000022  f7fffffe          BL       USBH_MSC_Write10
000026  4607              MOV      r7,r0
;;;150    						USBH_MSC_HandleBOTXfer(&USB_OTG_Core, &USB_Host);
000028  490c              LDR      r1,|L5.92|
00002a  480b              LDR      r0,|L5.88|
00002c  f7fffffe          BL       USBH_MSC_HandleBOTXfer
;;;151    
;;;152    						if(!HCD_IsDeviceConnected(&USB_OTG_Core))
000030  4809              LDR      r0,|L5.88|
000032  f7fffffe          BL       HCD_IsDeviceConnected
000036  b900              CBNZ     r0,|L5.58|
;;;153    						{
;;;154    							break;
000038  e001              B        |L5.62|
                  |L5.58|
;;;155    						}
;;;156    					}
;;;157    					while(status == USBH_MSC_BUSY );
00003a  2f03              CMP      r7,#3
00003c  d0ed              BEQ      |L5.26|
                  |L5.62|
00003e  bf00              NOP                            ;154
                  |L5.64|
;;;158    
;;;159    				}
;;;160    
;;;161    				if (status == USBH_MSC_OK)
000040  b90f              CBNZ     r7,|L5.70|
;;;162    				{
;;;163    					res = RES_OK;
000042  2400              MOVS     r4,#0
000044  e000              B        |L5.72|
                  |L5.70|
;;;164    				}
;;;165    				else
;;;166    				{
;;;167    					res = RES_ERROR;
000046  2401              MOVS     r4,#1
                  |L5.72|
;;;168    				}
;;;169    			}
;;;170    			break;
000048  e001              B        |L5.78|
                  |L5.74|
;;;171    
;;;172    		default:
;;;173    			res = RES_PARERR;
00004a  2404              MOVS     r4,#4
;;;174    			break;
00004c  bf00              NOP      
                  |L5.78|
00004e  bf00              NOP                            ;170
;;;175    	}
;;;176    	return res;
000050  4620              MOV      r0,r4
;;;177    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;178    #endif
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      USB_OTG_Core
                  |L5.92|
                          DCD      USB_Host

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;241    */
;;;242    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;243    {
;;;244    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2013-01-01 00:00:00 */
;;;245    
;;;246    	return	  ((DWORD)(2013 - 1980) << 25)	/* Year = 2013 */
;;;247    			| ((DWORD)1 << 21)				/* Month = 1 */
;;;248    			| ((DWORD)1 << 16)				/* Day_m = 1*/
;;;249    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;250    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;251    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;252    }
000002  4770              BX       lr
                          ENDP

                  |L6.4|
                          DCD      0x42210000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FatFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_b3252454____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REVSH|
#line 144
|__asm___8_diskio_c_b3252454____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
