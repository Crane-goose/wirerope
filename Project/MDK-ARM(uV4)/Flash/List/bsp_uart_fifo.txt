; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\FatFS\src -I..\..\User\usbh_mass_storage -ID:\Software\keil\ARM\RV31\INC -ID:\Software\keil\ARM\CMSIS\Include -ID:\Software\keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=518 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp_stm32f4xx\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;95     */
;;;96     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;97     {
;;;98     	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L1.8|
;;;99     	{
;;;100    		#if UART1_FIFO_EN == 1
;;;101    			return &g_tUart1;
000004  480b              LDR      r0,|L1.52|
                  |L1.6|
;;;102    		#else
;;;103    			return 0;
;;;104    		#endif
;;;105    	}
;;;106    	else if (_ucPort == COM2)
;;;107    	{
;;;108    		#if UART2_FIFO_EN == 1
;;;109    			return &g_tUart2;
;;;110    		#else
;;;111    			return;
;;;112    		#endif
;;;113    	}
;;;114    	else if (_ucPort == COM3)
;;;115    	{
;;;116    		#if UART3_FIFO_EN == 1
;;;117    			return &g_tUart3;
;;;118    		#else
;;;119    			return 0;
;;;120    		#endif
;;;121    	}
;;;122    	else if (_ucPort == COM4)
;;;123    	{
;;;124    		#if UART4_FIFO_EN == 1
;;;125    			return &g_tUart4;
;;;126    		#else
;;;127    			return 0;
;;;128    		#endif
;;;129    	}
;;;130    	else if (_ucPort == COM5)
;;;131    	{
;;;132    		#if UART5_FIFO_EN == 1
;;;133    			return &g_tUart5;
;;;134    		#else
;;;135    			return 0;
;;;136    		#endif
;;;137    	}
;;;138    	else if (_ucPort == COM6)
;;;139    	{
;;;140    		#if UART6_FIFO_EN == 1
;;;141    			return &g_tUart6;
;;;142    		#else
;;;143    			return 0;
;;;144    		#endif
;;;145    	}
;;;146    	else
;;;147    	{
;;;148    		/* 不做任何处理 */
;;;149    		return 0;
;;;150    	}
;;;151    }
000006  4770              BX       lr
                  |L1.8|
000008  2901              CMP      r1,#1                 ;106
00000a  d101              BNE      |L1.16|
00000c  480a              LDR      r0,|L1.56|
00000e  e7fa              B        |L1.6|
                  |L1.16|
000010  2902              CMP      r1,#2                 ;114
000012  d101              BNE      |L1.24|
000014  4809              LDR      r0,|L1.60|
000016  e7f6              B        |L1.6|
                  |L1.24|
000018  2903              CMP      r1,#3                 ;122
00001a  d101              BNE      |L1.32|
00001c  2000              MOVS     r0,#0                 ;127
00001e  e7f2              B        |L1.6|
                  |L1.32|
000020  2904              CMP      r1,#4                 ;130
000022  d101              BNE      |L1.40|
000024  2000              MOVS     r0,#0                 ;135
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  2905              CMP      r1,#5                 ;138
00002a  d101              BNE      |L1.48|
00002c  4804              LDR      r0,|L1.64|
00002e  e7ea              B        |L1.6|
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;149
000032  e7e8              B        |L1.6|
;;;152    
                          ENDP

                  |L1.52|
                          DCD      g_tUart1
                  |L1.56|
                          DCD      g_tUart2
                  |L1.60|
                          DCD      g_tUart3
                  |L1.64|
                          DCD      g_tUart6

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;872    */
;;;873    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;874    {
;;;875    	NVIC_InitTypeDef NVIC_InitStructure;
;;;876    
;;;877    	/* Configure the NVIC Preemption Priority Bits */
;;;878    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
000002  f44f60e0          MOV      r0,#0x700
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;879    
;;;880    #if UART1_FIFO_EN == 1
;;;881    	/* 使能串口1中断 */
;;;882    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00000a  2025              MOVS     r0,#0x25
00000c  f88d0000          STRB     r0,[sp,#0]
;;;883    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000010  2000              MOVS     r0,#0
000012  f88d0002          STRB     r0,[sp,#2]
;;;884    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000016  2001              MOVS     r0,#1
000018  f88d0003          STRB     r0,[sp,#3]
;;;885    	NVIC_Init(&NVIC_InitStructure);
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       NVIC_Init
;;;886    #endif
;;;887    
;;;888    #if UART2_FIFO_EN == 1
;;;889    	/* 使能串口2中断 */
;;;890    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000022  2026              MOVS     r0,#0x26
000024  f88d0000          STRB     r0,[sp,#0]
;;;891    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000028  2001              MOVS     r0,#1
00002a  f88d0002          STRB     r0,[sp,#2]
;;;892    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00002e  f88d0003          STRB     r0,[sp,#3]
;;;893    	NVIC_Init(&NVIC_InitStructure);
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       NVIC_Init
;;;894    #endif
;;;895    
;;;896    #if UART3_FIFO_EN == 1
;;;897    	/* 使能串口3中断t */
;;;898    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
000038  2027              MOVS     r0,#0x27
00003a  f88d0000          STRB     r0,[sp,#0]
;;;899    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
00003e  2002              MOVS     r0,#2
000040  f88d0002          STRB     r0,[sp,#2]
;;;900    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000044  2001              MOVS     r0,#1
000046  f88d0003          STRB     r0,[sp,#3]
;;;901    	NVIC_Init(&NVIC_InitStructure);
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       NVIC_Init
;;;902    #endif
;;;903    
;;;904    #if UART4_FIFO_EN == 1
;;;905    	/* 使能串口4中断t */
;;;906    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;907    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
;;;908    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;909    	NVIC_Init(&NVIC_InitStructure);
;;;910    #endif
;;;911    
;;;912    #if UART5_FIFO_EN == 1
;;;913    	/* 使能串口5中断t */
;;;914    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;915    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
;;;916    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;917    	NVIC_Init(&NVIC_InitStructure);
;;;918    #endif
;;;919    
;;;920    #if UART6_FIFO_EN == 1
;;;921    	/* 使能串口6中断t */
;;;922    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
000050  2047              MOVS     r0,#0x47
000052  f88d0000          STRB     r0,[sp,#0]
;;;923    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
000056  2005              MOVS     r0,#5
000058  f88d0002          STRB     r0,[sp,#2]
;;;924    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00005c  2001              MOVS     r0,#1
00005e  f88d0003          STRB     r0,[sp,#3]
;;;925    	NVIC_Init(&NVIC_InitStructure);
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       NVIC_Init
;;;926    #endif
;;;927    }
000068  bd08              POP      {r3,pc}
;;;928    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;462    */
;;;463    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;464    {
000002  b087              SUB      sp,sp,#0x1c
;;;465    	GPIO_InitTypeDef GPIO_InitStructure;
;;;466    	USART_InitTypeDef USART_InitStructure;
;;;467    
;;;468    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;469    
;;;470    	/* 第1步： 配置GPIO */
;;;471    	#if 1	/* TX = PA9   RX = PA10 */
;;;472    		/* 打开 GPIO 时钟 */
;;;473    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;474    
;;;475    		/* 打开 UART 时钟 */
;;;476    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2010              MOVS     r0,#0x10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;477    
;;;478    		/* 将 PA9 映射为 USART1_TX */
;;;479    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
000014  2207              MOVS     r2,#7
000016  2109              MOVS     r1,#9
000018  489c              LDR      r0,|L3.652|
00001a  f7fffffe          BL       GPIO_PinAFConfig
;;;480    
;;;481    		/* 将 PA10 映射为 USART1_RX */
;;;482    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_USART1);
00001e  2207              MOVS     r2,#7
000020  210a              MOVS     r1,#0xa
000022  489a              LDR      r0,|L3.652|
000024  f7fffffe          BL       GPIO_PinAFConfig
;;;483    
;;;484    		/* 配置 USART Tx 为复用功能 */
;;;485    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000028  2000              MOVS     r0,#0
00002a  f88d001a          STRB     r0,[sp,#0x1a]
;;;486    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
00002e  2001              MOVS     r0,#1
000030  f88d001b          STRB     r0,[sp,#0x1b]
;;;487    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
000034  2002              MOVS     r0,#2
000036  f88d0018          STRB     r0,[sp,#0x18]
;;;488    
;;;489    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00003a  0200              LSLS     r0,r0,#8
00003c  9005              STR      r0,[sp,#0x14]
;;;490    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003e  2002              MOVS     r0,#2
000040  f88d0019          STRB     r0,[sp,#0x19]
;;;491    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000044  a905              ADD      r1,sp,#0x14
000046  4891              LDR      r0,|L3.652|
000048  f7fffffe          BL       GPIO_Init
;;;492    
;;;493    		/* 配置 USART Rx 为复用功能 */
;;;494    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00004c  2002              MOVS     r0,#2
00004e  f88d0018          STRB     r0,[sp,#0x18]
;;;495    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000052  0240              LSLS     r0,r0,#9
000054  9005              STR      r0,[sp,#0x14]
;;;496    		GPIO_Init(GPIOA, &GPIO_InitStructure);
000056  a905              ADD      r1,sp,#0x14
000058  488c              LDR      r0,|L3.652|
00005a  f7fffffe          BL       GPIO_Init
;;;497    	#else	/* TX = PB6   RX = PB7  */
;;;498    		/* 打开 GPIO 时钟 */
;;;499    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
;;;500    
;;;501    		/* 打开 UART 时钟 */
;;;502    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
;;;503    
;;;504    		/* 将 PB6 映射为 USART1_TX */
;;;505    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_USART1);
;;;506    
;;;507    		/* 将 PB7 映射为 USART1_RX */
;;;508    		GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_USART1);
;;;509    
;;;510    		/* 配置 USART Tx 为复用功能 */
;;;511    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;512    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;513    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;514    
;;;515    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;516    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;517    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;518    
;;;519    		/* 配置 USART Rx 为复用功能 */
;;;520    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;521    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;522    		GPIO_Init(GPIOB, &GPIO_InitStructure);
;;;523    	#endif
;;;524    
;;;525    	/* 第2步： 配置串口硬件参数 */
;;;526    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
00005e  f44f30e1          MOV      r0,#0x1c200
000062  9001              STR      r0,[sp,#4]
;;;527    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000064  2000              MOVS     r0,#0
000066  f8ad0008          STRH     r0,[sp,#8]
;;;528    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00006a  f8ad000a          STRH     r0,[sp,#0xa]
;;;529    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00006e  f8ad000c          STRH     r0,[sp,#0xc]
;;;530    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000072  f8ad0010          STRH     r0,[sp,#0x10]
;;;531    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000076  200c              MOVS     r0,#0xc
000078  f8ad000e          STRH     r0,[sp,#0xe]
;;;532    	USART_Init(USART1, &USART_InitStructure);
00007c  a901              ADD      r1,sp,#4
00007e  4884              LDR      r0,|L3.656|
000080  f7fffffe          BL       USART_Init
;;;533    
;;;534    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000084  2201              MOVS     r2,#1
000086  f2405125          MOV      r1,#0x525
00008a  4881              LDR      r0,|L3.656|
00008c  f7fffffe          BL       USART_ITConfig
;;;535    	/*
;;;536    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;537    		注意: 不要在此处打开发送中断
;;;538    		发送中断使能在SendUart()函数打开
;;;539    	*/
;;;540    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000090  2101              MOVS     r1,#1
000092  487f              LDR      r0,|L3.656|
000094  f7fffffe          BL       USART_Cmd
;;;541    
;;;542    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;543    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;544    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000098  2140              MOVS     r1,#0x40
00009a  487d              LDR      r0,|L3.656|
00009c  f7fffffe          BL       USART_ClearFlag
;;;545    #endif
;;;546    
;;;547    #if UART2_FIFO_EN == 1		/* 串口2 TX = PD5   RX = PD6 或  TX = PA2， RX = PA3  */
;;;548    	/* 第1步： 配置GPIO */
;;;549    	#if 0	/* 串口2 TX = PD5   RX = PD6 */
;;;550    		/* 打开 GPIO 时钟 */
;;;551    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
;;;552    
;;;553    		/* 打开 UART 时钟 */
;;;554    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;555    
;;;556    		/* 将 PD5 映射为 USART2_TX */
;;;557    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_USART2);
;;;558    
;;;559    		/* 将 PD6 映射为 USART2_RX */
;;;560    		GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_USART2);
;;;561    
;;;562    		/* 配置 USART Tx 为复用功能 */
;;;563    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;564    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;565    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;566    
;;;567    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;568    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;569    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;570    
;;;571    		/* 配置 USART Rx 为复用功能 */
;;;572    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;573    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
;;;574    		GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;575    
;;;576    	#else	/* 串口2   TX = PA2， RX = PA3 */
;;;577    		/* 打开 GPIO 时钟 */
;;;578    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
0000a0  2101              MOVS     r1,#1
0000a2  4608              MOV      r0,r1
0000a4  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;579    
;;;580    		/* 打开 UART 时钟 */
;;;581    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  0448              LSLS     r0,r1,#17
0000ac  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;582    
;;;583    		/* 将 PA2 映射为 USART2_TX. 在STM32-V5板中，PA2 管脚用于以太网 */
;;;584    		//GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
;;;585    
;;;586    		/* 将 PA3 映射为 USART2_RX */
;;;587    		GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
0000b0  2207              MOVS     r2,#7
0000b2  2103              MOVS     r1,#3
0000b4  4875              LDR      r0,|L3.652|
0000b6  f7fffffe          BL       GPIO_PinAFConfig
;;;588    
;;;589    		/* 配置 USART Tx 为复用功能 */
;;;590    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
0000ba  2000              MOVS     r0,#0
0000bc  f88d001a          STRB     r0,[sp,#0x1a]
;;;591    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
0000c0  2001              MOVS     r0,#1
0000c2  f88d001b          STRB     r0,[sp,#0x1b]
;;;592    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
0000c6  2002              MOVS     r0,#2
0000c8  f88d0018          STRB     r0,[sp,#0x18]
;;;593    
;;;594    		//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;595    		//GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;596    		//GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;597    
;;;598    		/* 配置 USART Rx 为复用功能 */
;;;599    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
0000cc  f88d0018          STRB     r0,[sp,#0x18]
;;;600    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000d0  2008              MOVS     r0,#8
0000d2  9005              STR      r0,[sp,#0x14]
;;;601    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000d4  2002              MOVS     r0,#2
0000d6  f88d0019          STRB     r0,[sp,#0x19]
;;;602    		GPIO_Init(GPIOA, &GPIO_InitStructure);
0000da  a905              ADD      r1,sp,#0x14
0000dc  486b              LDR      r0,|L3.652|
0000de  f7fffffe          BL       GPIO_Init
;;;603    	#endif
;;;604    
;;;605    	/* 第2步： 配置串口硬件参数 */
;;;606    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
0000e2  f44f5016          MOV      r0,#0x2580
0000e6  9001              STR      r0,[sp,#4]
;;;607    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000e8  2000              MOVS     r0,#0
0000ea  f8ad0008          STRH     r0,[sp,#8]
;;;608    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000ee  f8ad000a          STRH     r0,[sp,#0xa]
;;;609    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000f2  f8ad000c          STRH     r0,[sp,#0xc]
;;;610    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000f6  f8ad0010          STRH     r0,[sp,#0x10]
;;;611    	USART_InitStructure.USART_Mode = USART_Mode_Rx;		/* 仅选择接收模式 */
0000fa  2004              MOVS     r0,#4
0000fc  f8ad000e          STRH     r0,[sp,#0xe]
;;;612    	USART_Init(USART2, &USART_InitStructure);
000100  a901              ADD      r1,sp,#4
000102  4864              LDR      r0,|L3.660|
000104  f7fffffe          BL       USART_Init
;;;613    
;;;614    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000108  2201              MOVS     r2,#1
00010a  f2405125          MOV      r1,#0x525
00010e  4861              LDR      r0,|L3.660|
000110  f7fffffe          BL       USART_ITConfig
;;;615    	/*
;;;616    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;617    		注意: 不要在此处打开发送中断
;;;618    		发送中断使能在SendUart()函数打开
;;;619    	*/
;;;620    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
000114  2101              MOVS     r1,#1
000116  485f              LDR      r0,|L3.660|
000118  f7fffffe          BL       USART_Cmd
;;;621    
;;;622    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;623    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;624    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00011c  2140              MOVS     r1,#0x40
00011e  485d              LDR      r0,|L3.660|
000120  f7fffffe          BL       USART_ClearFlag
;;;625    #endif
;;;626    
;;;627    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;628    
;;;629    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;630    	{
;;;631    		RCC_AHB1PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
000124  2101              MOVS     r1,#1
000126  2002              MOVS     r0,#2
000128  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;632    
;;;633    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;		/* 设为输出口 */
00012c  2001              MOVS     r0,#1
00012e  f88d0018          STRB     r0,[sp,#0x18]
;;;634    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		/* 设为推挽模式 */
000132  2000              MOVS     r0,#0
000134  f88d001a          STRB     r0,[sp,#0x1a]
;;;635    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;	/* 上下拉电阻不使能 */
000138  f88d001b          STRB     r0,[sp,#0x1b]
;;;636    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;	/* IO口最大速度 */
00013c  2003              MOVS     r0,#3
00013e  f88d0019          STRB     r0,[sp,#0x19]
;;;637    
;;;638    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000142  2004              MOVS     r0,#4
000144  9005              STR      r0,[sp,#0x14]
;;;639    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
000146  a905              ADD      r1,sp,#0x14
000148  4853              LDR      r0,|L3.664|
00014a  f7fffffe          BL       GPIO_Init
;;;640    	}
;;;641    
;;;642    	/* 打开 GPIO 时钟 */
;;;643    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
00014e  2101              MOVS     r1,#1
000150  2002              MOVS     r0,#2
000152  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;644    
;;;645    	/* 打开 UART 时钟 */
;;;646    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000156  2101              MOVS     r1,#1
000158  0488              LSLS     r0,r1,#18
00015a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;647    
;;;648    	/* 将 PB10 映射为 USART3_TX */
;;;649    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_USART3);
00015e  2207              MOVS     r2,#7
000160  210a              MOVS     r1,#0xa
000162  484d              LDR      r0,|L3.664|
000164  f7fffffe          BL       GPIO_PinAFConfig
;;;650    
;;;651    	/* 将 PB11 映射为 USART3_RX */
;;;652    	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_USART3);
000168  2207              MOVS     r2,#7
00016a  210b              MOVS     r1,#0xb
00016c  484a              LDR      r0,|L3.664|
00016e  f7fffffe          BL       GPIO_PinAFConfig
;;;653    
;;;654    	/* 配置 USART Tx 为复用功能 */
;;;655    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
000172  2000              MOVS     r0,#0
000174  f88d001a          STRB     r0,[sp,#0x1a]
;;;656    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
000178  2001              MOVS     r0,#1
00017a  f88d001b          STRB     r0,[sp,#0x1b]
;;;657    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
00017e  2002              MOVS     r0,#2
000180  f88d0018          STRB     r0,[sp,#0x18]
;;;658    
;;;659    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000184  0240              LSLS     r0,r0,#9
000186  9005              STR      r0,[sp,#0x14]
;;;660    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000188  2002              MOVS     r0,#2
00018a  f88d0019          STRB     r0,[sp,#0x19]
;;;661    	GPIO_Init(GPIOB, &GPIO_InitStructure);
00018e  a905              ADD      r1,sp,#0x14
000190  4841              LDR      r0,|L3.664|
000192  f7fffffe          BL       GPIO_Init
;;;662    
;;;663    	/* 配置 USART Rx 为复用功能 */
;;;664    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000196  2002              MOVS     r0,#2
000198  f88d0018          STRB     r0,[sp,#0x18]
;;;665    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
00019c  0280              LSLS     r0,r0,#10
00019e  9005              STR      r0,[sp,#0x14]
;;;666    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0001a0  a905              ADD      r1,sp,#0x14
0001a2  483d              LDR      r0,|L3.664|
0001a4  f7fffffe          BL       GPIO_Init
;;;667    
;;;668    	/* 第2步： 配置串口硬件参数 */
;;;669    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
0001a8  f44f5016          MOV      r0,#0x2580
0001ac  9001              STR      r0,[sp,#4]
;;;670    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0001ae  2000              MOVS     r0,#0
0001b0  f8ad0008          STRH     r0,[sp,#8]
;;;671    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0001b4  f8ad000a          STRH     r0,[sp,#0xa]
;;;672    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0001b8  f8ad000c          STRH     r0,[sp,#0xc]
;;;673    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0001bc  f8ad0010          STRH     r0,[sp,#0x10]
;;;674    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0001c0  200c              MOVS     r0,#0xc
0001c2  f8ad000e          STRH     r0,[sp,#0xe]
;;;675    	USART_Init(USART3, &USART_InitStructure);
0001c6  a901              ADD      r1,sp,#4
0001c8  4834              LDR      r0,|L3.668|
0001ca  f7fffffe          BL       USART_Init
;;;676    
;;;677    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0001ce  2201              MOVS     r2,#1
0001d0  f2405125          MOV      r1,#0x525
0001d4  4831              LDR      r0,|L3.668|
0001d6  f7fffffe          BL       USART_ITConfig
;;;678    	/*
;;;679    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;680    		注意: 不要在此处打开发送中断
;;;681    		发送中断使能在SendUart()函数打开
;;;682    	*/
;;;683    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
0001da  2101              MOVS     r1,#1
0001dc  482f              LDR      r0,|L3.668|
0001de  f7fffffe          BL       USART_Cmd
;;;684    
;;;685    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;686    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;687    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0001e2  2140              MOVS     r1,#0x40
0001e4  482d              LDR      r0,|L3.668|
0001e6  f7fffffe          BL       USART_ClearFlag
;;;688    #endif
;;;689    
;;;690    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;691    	/* 第1步： 配置GPIO */
;;;692    
;;;693    	/* 打开 GPIO 时钟 */
;;;694    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
;;;695    
;;;696    	/* 打开 UART 时钟 */
;;;697    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;698    
;;;699    	/* 将 PC10 映射为 UART4_TX */
;;;700    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;701    
;;;702    	/* 将 PC11 映射为 UART4_RX */
;;;703    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART1);
;;;704    
;;;705    	/* 配置 USART Tx 为复用功能 */
;;;706    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;707    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;708    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;709    
;;;710    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;711    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;712    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;713    
;;;714    	/* 配置 USART Rx 为复用功能 */
;;;715    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;716    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;717    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;718    
;;;719    	/* 第2步： 配置串口硬件参数 */
;;;720    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;721    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;722    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;723    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;724    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;725    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;726    	USART_Init(UART4, &USART_InitStructure);
;;;727    
;;;728    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;729    	/*
;;;730    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;731    		注意: 不要在此处打开发送中断
;;;732    		发送中断使能在SendUart()函数打开
;;;733    	*/
;;;734    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;735    
;;;736    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;737    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;738    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;739    #endif
;;;740    
;;;741    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;742    	/* 第1步： 配置GPIO */
;;;743    
;;;744    	/* 打开 GPIO 时钟 */
;;;745    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOD, ENABLE);
;;;746    
;;;747    	/* 打开 UART 时钟 */
;;;748    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;749    
;;;750    	/* 将 PC12 映射为 UART5_TX */
;;;751    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_UART5);
;;;752    
;;;753    	/* 将 PD2 映射为 UART5_RX */
;;;754    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_UART5);
;;;755    
;;;756    	/* 配置 UART Tx 为复用功能 */
;;;757    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
;;;758    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
;;;759    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
;;;760    
;;;761    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;762    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;763    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;764    
;;;765    	/* 配置 UART Rx 为复用功能 */
;;;766    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;767    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;768    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;769    
;;;770    	/* 第2步： 配置串口硬件参数 */
;;;771    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;772    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;773    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;774    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;775    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;776    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;777    	USART_Init(UART5, &USART_InitStructure);
;;;778    
;;;779    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;780    	/*
;;;781    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;782    		注意: 不要在此处打开发送中断
;;;783    		发送中断使能在SendUart()函数打开
;;;784    	*/
;;;785    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;786    
;;;787    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;788    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;789    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;790    #endif
;;;791    
;;;792    #if UART6_FIFO_EN == 1			/* PG14/USART6_TX , PC7/USART6_RX,PG8/USART6_RTS, PG15/USART6_CTS */
;;;793    	/* 第1步： 配置GPIO */
;;;794    
;;;795    //	/* 打开 GPIO 时钟 */
;;;796    //	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC |RCC_AHB1Periph_GPIOG, ENABLE);
;;;797    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC , ENABLE);
0001ea  2101              MOVS     r1,#1
0001ec  2004              MOVS     r0,#4
0001ee  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;798    
;;;799    	/* 打开 UART 时钟 */
;;;800    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, ENABLE);
0001f2  2101              MOVS     r1,#1
0001f4  2020              MOVS     r0,#0x20
0001f6  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;801    
;;;802    	/* 将 PG14 映射为 USART6_TX */
;;;803    //	GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_USART6);
;;;804    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_USART6);
0001fa  2208              MOVS     r2,#8
0001fc  2106              MOVS     r1,#6
0001fe  4828              LDR      r0,|L3.672|
000200  f7fffffe          BL       GPIO_PinAFConfig
;;;805    
;;;806    	/* 将 PC7 映射为 USART6_RX */
;;;807    	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_USART6);
000204  2208              MOVS     r2,#8
000206  2107              MOVS     r1,#7
000208  4825              LDR      r0,|L3.672|
00020a  f7fffffe          BL       GPIO_PinAFConfig
;;;808    
;;;809    	/* 将 PG8 映射为 USART6_RTS */
;;;810    //	GPIO_PinAFConfig(GPIOG, GPIO_PinSource8, GPIO_AF_USART6);
;;;811    
;;;812    //	/* 将 PG15 映射为 USART6_CTS */
;;;813    //	GPIO_PinAFConfig(GPIOG, GPIO_PinSource15, GPIO_AF_USART6);
;;;814    
;;;815    	/* 配置 PG14/USART6_TX 为复用功能 */
;;;816    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;	/* 输出类型为推挽 */
00020e  2000              MOVS     r0,#0
000210  f88d001a          STRB     r0,[sp,#0x1a]
;;;817    	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;	/* 内部上拉电阻使能 */
000214  2001              MOVS     r0,#1
000216  f88d001b          STRB     r0,[sp,#0x1b]
;;;818    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;	/* 复用模式 */
00021a  2002              MOVS     r0,#2
00021c  f88d0018          STRB     r0,[sp,#0x18]
;;;819    
;;;820    //	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
;;;821    //	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;822    //	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;823    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000220  2040              MOVS     r0,#0x40
000222  9005              STR      r0,[sp,#0x14]
;;;824    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000224  2002              MOVS     r0,#2
000226  f88d0019          STRB     r0,[sp,#0x19]
;;;825    	GPIO_Init(GPIOC, &GPIO_InitStructure);
00022a  a905              ADD      r1,sp,#0x14
00022c  481c              LDR      r0,|L3.672|
00022e  f7fffffe          BL       GPIO_Init
;;;826    
;;;827    	/* 配置 PC7/USART6_RX 为复用功能 */
;;;828    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000232  2002              MOVS     r0,#2
000234  f88d0018          STRB     r0,[sp,#0x18]
;;;829    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
000238  2080              MOVS     r0,#0x80
00023a  9005              STR      r0,[sp,#0x14]
;;;830    	GPIO_Init(GPIOC, &GPIO_InitStructure);
00023c  a905              ADD      r1,sp,#0x14
00023e  4818              LDR      r0,|L3.672|
000240  f7fffffe          BL       GPIO_Init
;;;831    
;;;832    //	/* 配置 PG8/USART6_RTS 为复用功能 */
;;;833    //	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;834    //	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
;;;835    //	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;836    
;;;837    //	/* 配置 PG15/USART6_CTS 为复用功能 */
;;;838    //	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;839    //	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;
;;;840    //	GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;841    
;;;842    	/* 第2步： 配置串口硬件参数 */
;;;843    	USART_InitStructure.USART_BaudRate = UART6_BAUD;	/* 波特率 */
000244  f44f30e1          MOV      r0,#0x1c200
000248  9001              STR      r0,[sp,#4]
;;;844    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00024a  2000              MOVS     r0,#0
00024c  f8ad0008          STRH     r0,[sp,#8]
;;;845    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000250  f8ad000a          STRH     r0,[sp,#0xa]
;;;846    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000254  f8ad000c          STRH     r0,[sp,#0xc]
;;;847    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	/* 选择硬件流控 */
000258  f8ad0010          STRH     r0,[sp,#0x10]
;;;848    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00025c  200c              MOVS     r0,#0xc
00025e  f8ad000e          STRH     r0,[sp,#0xe]
;;;849    	USART_Init(USART6, &USART_InitStructure);
000262  a901              ADD      r1,sp,#4
000264  480f              LDR      r0,|L3.676|
000266  f7fffffe          BL       USART_Init
;;;850    
;;;851    	USART_ITConfig(USART6, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00026a  2201              MOVS     r2,#1
00026c  f2405125          MOV      r1,#0x525
000270  480c              LDR      r0,|L3.676|
000272  f7fffffe          BL       USART_ITConfig
;;;852    	/*
;;;853    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;854    		注意: 不要在此处打开发送中断
;;;855    		发送中断使能在SendUart()函数打开
;;;856    	*/
;;;857    	USART_Cmd(USART6, ENABLE);		/* 使能串口 */
000276  2101              MOVS     r1,#1
000278  480a              LDR      r0,|L3.676|
00027a  f7fffffe          BL       USART_Cmd
;;;858    
;;;859    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;860    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;861    	USART_ClearFlag(USART6, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00027e  2140              MOVS     r1,#0x40
000280  4808              LDR      r0,|L3.676|
000282  f7fffffe          BL       USART_ClearFlag
;;;862    #endif
;;;863    }
000286  b007              ADD      sp,sp,#0x1c
000288  bd00              POP      {pc}
;;;864    
                          ENDP

00028a  0000              DCW      0x0000
                  |L3.652|
                          DCD      0x40020000
                  |L3.656|
                          DCD      0x40011000
                  |L3.660|
                          DCD      0x40004400
                  |L3.664|
                          DCD      0x40020400
                  |L3.668|
                          DCD      0x40004800
                  |L3.672|
                          DCD      0x40020800
                  |L3.676|
                          DCD      0x40011400

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1223   #if UART1_FIFO_EN == 1
;;;1224   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1225   {
;;;1226   	UartIRQ1(&g_tUart1);
000002  4802              LDR      r0,|L4.12|
000004  f7fffffe          BL       UartIRQ1
;;;1227   }
000008  bd10              POP      {r4,pc}
;;;1228   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      g_tUart1

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1230   #if UART2_FIFO_EN == 1
;;;1231   void USART2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1232   {
;;;1233   	UartIRQ(&g_tUart2);
000002  4802              LDR      r0,|L5.12|
000004  f7fffffe          BL       UartIRQ
;;;1234   }
000008  bd10              POP      {r4,pc}
;;;1235   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      g_tUart2

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;1237   #if UART3_FIFO_EN == 1
;;;1238   void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1239   {
;;;1240   	UartIRQ(&g_tUart3);
000002  4802              LDR      r0,|L6.12|
000004  f7fffffe          BL       UartIRQ
;;;1241   }
000008  bd10              POP      {r4,pc}
;;;1242   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      g_tUart3

                          AREA ||i.USART3_SendBefor||, CODE, READONLY, ALIGN=2

                  USART3_SendBefor PROC
;;;321    */
;;;322    void USART3_SendBefor(void)
000000  2004              MOVS     r0,#4
;;;323    {
;;;324    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L7.8|
000004  8008              STRH     r0,[r1,#0]
;;;325    }
000006  4770              BX       lr
;;;326    
                          ENDP

                  |L7.8|
                          DCD      0x40020418

                          AREA ||i.USART3_SendOver||, CODE, READONLY, ALIGN=2

                  USART3_SendOver PROC
;;;335    */
;;;336    void USART3_SendOver(void)
000000  2004              MOVS     r0,#4
;;;337    {
;;;338    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L8.8|
000004  8008              STRH     r0,[r1,#0]
;;;339    }
000006  4770              BX       lr
;;;340    
                          ENDP

                  |L8.8|
                          DCD      0x4002041a

                          AREA ||i.USART6_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART6_IRQHandler PROC
;;;1258   #if UART6_FIFO_EN == 1
;;;1259   void USART6_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1260   {
;;;1261   	UartIRQ(&g_tUart6);
000002  4802              LDR      r0,|L9.12|
000004  f7fffffe          BL       UartIRQ
;;;1262   }
000008  bd10              POP      {r4,pc}
;;;1263   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      g_tUart6

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;1007   */
;;;1008   static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;1009   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1010   	uint16_t usCount;
;;;1011   
;;;1012   	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;1013   	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;1014   	usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;1015   	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;1016   
;;;1017   	/* 如果读和写索引相同，则返回0 */
;;;1018   	//if (_pUart->usRxRead == usRxWrite)
;;;1019   	if (usCount == 0)	/* 已经没有数据 */
000014  b90e              CBNZ     r6,|L10.26|
;;;1020   	{
;;;1021   		return 0;
000016  2000              MOVS     r0,#0
                  |L10.24|
;;;1022   	}
;;;1023   	else
;;;1024   	{
;;;1025   		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;1026   
;;;1027   		/* 改写FIFO读索引 */
;;;1028   		DISABLE_INT();
;;;1029   		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;1030   		{
;;;1031   			_pUart->usRxRead = 0;
;;;1032   		}
;;;1033   		_pUart->usRxCount--;
;;;1034   		ENABLE_INT();
;;;1035   		return 1;
;;;1036   	}
;;;1037   }
000018  bd70              POP      {r4-r6,pc}
                  |L10.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;1025
00001c  68a0              LDR      r0,[r4,#8]            ;1025
00001e  5c40              LDRB     r0,[r0,r1]            ;1025
000020  7028              STRB     r0,[r5,#0]            ;1025
000022  2001              MOVS     r0,#1                 ;1028
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;1029
00002a  1c40              ADDS     r0,r0,#1              ;1029
00002c  b280              UXTH     r0,r0                 ;1029
00002e  8320              STRH     r0,[r4,#0x18]         ;1029
000030  89e1              LDRH     r1,[r4,#0xe]          ;1029
000032  4288              CMP      r0,r1                 ;1029
000034  db01              BLT      |L10.58|
000036  2000              MOVS     r0,#0                 ;1031
000038  8320              STRH     r0,[r4,#0x18]         ;1031
                  |L10.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;1033
00003c  1e40              SUBS     r0,r0,#1              ;1033
00003e  8360              STRH     r0,[r4,#0x1a]         ;1033
000040  2000              MOVS     r0,#0                 ;1034
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;1035
000048  e7e6              B        |L10.24|
;;;1038   
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;1046   */
;;;1047   static void UartIRQ(UART_T *_pUart)
000000  b510              PUSH     {r4,lr}
;;;1048   {
000002  4604              MOV      r4,r0
;;;1049   	/* 处理接收中断  */
;;;1050   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L11.74|
;;;1051   	{
;;;1052   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1053   		_pUart->pRxBuf[_pUart->usRxWrite] = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  8ae2              LDRH     r2,[r4,#0x16]
000018  68a1              LDR      r1,[r4,#8]
00001a  5488              STRB     r0,[r1,r2]
;;;1054   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001c  8ae0              LDRH     r0,[r4,#0x16]
00001e  1c40              ADDS     r0,r0,#1
000020  b280              UXTH     r0,r0
000022  82e0              STRH     r0,[r4,#0x16]
000024  89e1              LDRH     r1,[r4,#0xe]
000026  4288              CMP      r0,r1
000028  db01              BLT      |L11.46|
;;;1055   		{
;;;1056   			_pUart->usRxWrite = 0;
00002a  2000              MOVS     r0,#0
00002c  82e0              STRH     r0,[r4,#0x16]
                  |L11.46|
;;;1057   		}
;;;1058   		if (_pUart->usRxCount < _pUart->usRxBufSize)
00002e  8b60              LDRH     r0,[r4,#0x1a]
000030  89e1              LDRH     r1,[r4,#0xe]
000032  4288              CMP      r0,r1
000034  da02              BGE      |L11.60|
;;;1059   		{
;;;1060   			_pUart->usRxCount++;
000036  8b60              LDRH     r0,[r4,#0x1a]
000038  1c40              ADDS     r0,r0,#1
00003a  8360              STRH     r0,[r4,#0x1a]
                  |L11.60|
;;;1061   		}
;;;1062   
;;;1063   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1064   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1065   		if (_pUart->usRxCount == 1)
00003c  8b60              LDRH     r0,[r4,#0x1a]
00003e  2801              CMP      r0,#1
000040  d103              BNE      |L11.74|
;;;1066   		{
;;;1067   			if (_pUart->ReciveNew)
000042  6a60              LDR      r0,[r4,#0x24]
000044  b108              CBZ      r0,|L11.74|
;;;1068   			{
;;;1069   				_pUart->ReciveNew();
000046  6a60              LDR      r0,[r4,#0x24]
000048  4780              BLX      r0
                  |L11.74|
;;;1070   			}
;;;1071   		}		
;;;1072   	}
;;;1073   
;;;1074   	/* 处理发送缓冲区空中断 */
;;;1075   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  f2407127          MOV      r1,#0x727
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L11.154|
;;;1076   	{
;;;1077   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1078   		if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L11.116|
;;;1079   		{
;;;1080   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1081   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  2200              MOVS     r2,#0
00005c  f2407127          MOV      r1,#0x727
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       USART_ITConfig
;;;1082   
;;;1083   			/* 使能数据发送完毕中断 */
;;;1084   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2406126          MOV      r1,#0x626
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L11.228|
                  |L11.116|
;;;1085   		}
;;;1086   		else
;;;1087   		{
;;;1088   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1089   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  8a63              LDRH     r3,[r4,#0x12]
000076  6862              LDR      r2,[r4,#4]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;1090   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L11.146|
;;;1091   			{
;;;1092   				_pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L11.146|
;;;1093   			}
;;;1094   			_pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L11.228|
                  |L11.154|
;;;1095   		}
;;;1096   
;;;1097   	}
;;;1098   	/* 数据bit位全部发送完毕的中断 */
;;;1099   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  f2406126          MOV      r1,#0x626
00009e  6820              LDR      r0,[r4,#0]
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L11.228|
;;;1100   	{
;;;1101   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1102   		if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L11.192|
;;;1103   		{
;;;1104   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1105   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2406126          MOV      r1,#0x626
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       USART_ITConfig
;;;1106   
;;;1107   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1108   			if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L11.228|
;;;1109   			{
;;;1110   				_pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L11.228|
                  |L11.192|
;;;1111   			}
;;;1112   		}
;;;1113   		else
;;;1114   		{
;;;1115   			/* 正常情况下，不会进入此分支 */
;;;1116   			
;;;1117   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1118   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  8a63              LDRH     r3,[r4,#0x12]
0000c2  6862              LDR      r2,[r4,#4]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;1119   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L11.222|
;;;1120   			{
;;;1121   				_pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L11.222|
;;;1122   			}
;;;1123   			_pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L11.228|
;;;1124   		}
;;;1125   	}
;;;1126   }
0000e4  bd10              POP      {r4,pc}
;;;1127   
                          ENDP


                          AREA ||i.UartIRQ1||, CODE, READONLY, ALIGN=2

                  UartIRQ1 PROC
;;;1133   
;;;1134   static void UartIRQ1(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;1135   {
000002  4604              MOV      r4,r0
;;;1136   	u8 Res;
;;;1137   //	u8 clr=0;
;;;1138   	/* 处理接收中断  */
;;;1139   	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)	//接收中断(接收到的数据必须是0x0d 0x0a结尾)
000004  f2405125          MOV      r1,#0x525
000008  4836              LDR      r0,|L12.228|
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1d8              CBZ      r0,|L12.72|
;;;1140   	{
;;;1141   		Res =USART_ReceiveData(USART1);//(USART1->DR);	//读取接收到的数据
000010  4834              LDR      r0,|L12.228|
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;1142   			if((USART_RX_STA&(1<<15))==0)//接收未完成
000018  4833              LDR      r0,|L12.232|
00001a  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
00001c  f4004000          AND      r0,r0,#0x8000
000020  b990              CBNZ     r0,|L12.72|
;;;1143   			{
;;;1144   				if(USART_RX_STA<USART_REC_LEN)	//还可以接收数据
000022  4831              LDR      r0,|L12.232|
000024  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000026  2808              CMP      r0,#8
000028  da08              BGE      |L12.60|
;;;1145   				{
;;;1146   					USART_RX_BUF[USART_RX_STA++]=Res;	//记录接收到的值	 
00002a  482f              LDR      r0,|L12.232|
00002c  8801              LDRH     r1,[r0,#0]  ; USART_RX_STA
00002e  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000030  1c40              ADDS     r0,r0,#1
000032  4a2d              LDR      r2,|L12.232|
000034  8010              STRH     r0,[r2,#0]
000036  482d              LDR      r0,|L12.236|
000038  5445              STRB     r5,[r0,r1]
00003a  e005              B        |L12.72|
                  |L12.60|
;;;1147   				}else 
;;;1148   				{
;;;1149   					USART_RX_STA|=1<<15;				//强制标记接收完成
00003c  482a              LDR      r0,|L12.232|
00003e  8800              LDRH     r0,[r0,#0]  ; USART_RX_STA
000040  f4404000          ORR      r0,r0,#0x8000
000044  4928              LDR      r1,|L12.232|
000046  8008              STRH     r0,[r1,#0]
                  |L12.72|
;;;1150   				} 
;;;1151   			}	
;;;1152   	} 
;;;1153   	
;;;1154   //	if(USART_GetFlagStatus(USART3,USART_FLAG_IDLE)!=Bit_RESET)
;;;1155   //	{					                
;;;1156   //		clear=USART3->SR;                
;;;1157   //		clear=USART3->DR;							        
;;;1158   //		RxCounter=0;                
;;;1159   //	}	
;;;1160   
;;;1161   	/* 处理发送缓冲区空中断 */
;;;1162   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
000048  f2407127          MOV      r1,#0x727
00004c  6820              LDR      r0,[r4,#0]
00004e  f7fffffe          BL       USART_GetITStatus
000052  b308              CBZ      r0,|L12.152|
;;;1163   	{
;;;1164   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1165   		if (_pUart->usTxCount == 0)
000054  8aa0              LDRH     r0,[r4,#0x14]
000056  b960              CBNZ     r0,|L12.114|
;;;1166   		{
;;;1167   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1168   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
000058  2200              MOVS     r2,#0
00005a  f2407127          MOV      r1,#0x727
00005e  6820              LDR      r0,[r4,#0]
000060  f7fffffe          BL       USART_ITConfig
;;;1169   
;;;1170   			/* 使能数据发送完毕中断 */
;;;1171   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000064  2201              MOVS     r2,#1
000066  f2406126          MOV      r1,#0x626
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       USART_ITConfig
000070  e037              B        |L12.226|
                  |L12.114|
;;;1172   		}
;;;1173   		else
;;;1174   		{
;;;1175   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1176   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000072  8a63              LDRH     r3,[r4,#0x12]
000074  6862              LDR      r2,[r4,#4]
000076  5cd1              LDRB     r1,[r2,r3]
000078  6820              LDR      r0,[r4,#0]
00007a  f7fffffe          BL       USART_SendData
;;;1177   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
00007e  8a60              LDRH     r0,[r4,#0x12]
000080  1c40              ADDS     r0,r0,#1
000082  b280              UXTH     r0,r0
000084  8260              STRH     r0,[r4,#0x12]
000086  89a1              LDRH     r1,[r4,#0xc]
000088  4288              CMP      r0,r1
00008a  db01              BLT      |L12.144|
;;;1178   			{
;;;1179   				_pUart->usTxRead = 0;
00008c  2000              MOVS     r0,#0
00008e  8260              STRH     r0,[r4,#0x12]
                  |L12.144|
;;;1180   			}
;;;1181   			_pUart->usTxCount--;
000090  8aa0              LDRH     r0,[r4,#0x14]
000092  1e40              SUBS     r0,r0,#1
000094  82a0              STRH     r0,[r4,#0x14]
000096  e024              B        |L12.226|
                  |L12.152|
;;;1182   		}
;;;1183   
;;;1184   	}
;;;1185   	/* 数据bit位全部发送完毕的中断 */
;;;1186   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
000098  f2406126          MOV      r1,#0x626
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       USART_GetITStatus
0000a2  b1f0              CBZ      r0,|L12.226|
;;;1187   	{
;;;1188   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1189   		if (_pUart->usTxCount == 0)
0000a4  8aa0              LDRH     r0,[r4,#0x14]
0000a6  b950              CBNZ     r0,|L12.190|
;;;1190   		{
;;;1191   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1192   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000a8  2200              MOVS     r2,#0
0000aa  f2406126          MOV      r1,#0x626
0000ae  6820              LDR      r0,[r4,#0]
0000b0  f7fffffe          BL       USART_ITConfig
;;;1193   
;;;1194   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1195   			if (_pUart->SendOver)
0000b4  6a20              LDR      r0,[r4,#0x20]
0000b6  b1a0              CBZ      r0,|L12.226|
;;;1196   			{
;;;1197   				_pUart->SendOver();
0000b8  6a20              LDR      r0,[r4,#0x20]
0000ba  4780              BLX      r0
0000bc  e011              B        |L12.226|
                  |L12.190|
;;;1198   			}
;;;1199   		}
;;;1200   		else
;;;1201   		{
;;;1202   			/* 正常情况下，不会进入此分支 */
;;;1203   			
;;;1204   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1205   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000be  8a63              LDRH     r3,[r4,#0x12]
0000c0  6862              LDR      r2,[r4,#4]
0000c2  5cd1              LDRB     r1,[r2,r3]
0000c4  6820              LDR      r0,[r4,#0]
0000c6  f7fffffe          BL       USART_SendData
;;;1206   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000ca  8a60              LDRH     r0,[r4,#0x12]
0000cc  1c40              ADDS     r0,r0,#1
0000ce  b280              UXTH     r0,r0
0000d0  8260              STRH     r0,[r4,#0x12]
0000d2  89a1              LDRH     r1,[r4,#0xc]
0000d4  4288              CMP      r0,r1
0000d6  db01              BLT      |L12.220|
;;;1207   			{
;;;1208   				_pUart->usTxRead = 0;
0000d8  2000              MOVS     r0,#0
0000da  8260              STRH     r0,[r4,#0x12]
                  |L12.220|
;;;1209   			}
;;;1210   			_pUart->usTxCount--;
0000dc  8aa0              LDRH     r0,[r4,#0x14]
0000de  1e40              SUBS     r0,r0,#1
0000e0  82a0              STRH     r0,[r4,#0x14]
                  |L12.226|
;;;1211   		}
;;;1212   	}
;;;1213   }
0000e2  bd70              POP      {r4-r6,pc}
;;;1214   
                          ENDP

                  |L12.228|
                          DCD      0x40011000
                  |L12.232|
                          DCD      USART_RX_STA
                  |L12.236|
                          DCD      USART_RX_BUF

                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;936    */
;;;937    static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;938    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;939    	uint16_t i;
;;;940    
;;;941    	for (i = 0; i < _usLen; i++)
00000a  2500              MOVS     r5,#0
00000c  e027              B        |L13.94|
                  |L13.14|
;;;942    	{
;;;943    		/* 如果发送缓冲区已经满了，则等待缓冲区空 */		
;;;944    	#if 0
;;;945    		/* 
;;;946    			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;947    			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;948    			将导致while(1) 无法退出
;;;949    		*/
;;;950    		while (1)
;;;951    		{
;;;952    			uint16_t usRead;
;;;953    
;;;954    			DISABLE_INT();
;;;955    			usRead = _pUart->usTxRead;
;;;956    			ENABLE_INT();
;;;957    
;;;958    			if (++usRead >= _pUart->usTxBufSize)
;;;959    			{
;;;960    				usRead = 0;
;;;961    			}
;;;962    
;;;963    			if (usRead != _pUart->usTxWrite)
;;;964    			{
;;;965    				break;
;;;966    			}
;;;967    		}
;;;968    	#else
;;;969    		while (1)
00000e  e00c              B        |L13.42|
                  |L13.16|
;;;970    		{
;;;971    			uint16_t usCount;
;;;972    
;;;973    			DISABLE_INT();
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __set_PRIMASK
;;;974    			usCount = _pUart->usTxCount;
000016  f8b48014          LDRH     r8,[r4,#0x14]
;;;975    			ENABLE_INT();
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       __set_PRIMASK
;;;976    
;;;977    			if (usCount < _pUart->usTxBufSize)
000020  89a0              LDRH     r0,[r4,#0xc]
000022  4540              CMP      r0,r8
000024  dd00              BLE      |L13.40|
;;;978    			{
;;;979    				break;
000026  e001              B        |L13.44|
                  |L13.40|
;;;980    			}
;;;981    		}			
000028  bf00              NOP      
                  |L13.42|
00002a  e7f1              B        |L13.16|
                  |L13.44|
00002c  bf00              NOP                            ;979
;;;982    	#endif
;;;983    
;;;984    		/* 将新数据填入发送缓冲区 */
;;;985    		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00002e  5d70              LDRB     r0,[r6,r5]
000030  8a22              LDRH     r2,[r4,#0x10]
000032  6861              LDR      r1,[r4,#4]
000034  5488              STRB     r0,[r1,r2]
;;;986    
;;;987    		DISABLE_INT();
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       __set_PRIMASK
;;;988    		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
00003c  8a20              LDRH     r0,[r4,#0x10]
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
000042  8220              STRH     r0,[r4,#0x10]
000044  89a1              LDRH     r1,[r4,#0xc]
000046  4288              CMP      r0,r1
000048  db01              BLT      |L13.78|
;;;989    		{
;;;990    			_pUart->usTxWrite = 0;
00004a  2000              MOVS     r0,#0
00004c  8220              STRH     r0,[r4,#0x10]
                  |L13.78|
;;;991    		}
;;;992    		_pUart->usTxCount++;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  1c40              ADDS     r0,r0,#1
000052  82a0              STRH     r0,[r4,#0x14]
;;;993    		ENABLE_INT();
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       __set_PRIMASK
00005a  1c68              ADDS     r0,r5,#1              ;941
00005c  b285              UXTH     r5,r0                 ;941
                  |L13.94|
00005e  42bd              CMP      r5,r7                 ;941
000060  dbd5              BLT      |L13.14|
;;;994    	}
;;;995    
;;;996    	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000062  2201              MOVS     r2,#1
000064  f2407127          MOV      r1,#0x727
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       USART_ITConfig
;;;997    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;998    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;348    */
;;;349    static void UartVarInit(void)
000000  482b              LDR      r0,|L14.176|
;;;350    {
;;;351    #if UART1_FIFO_EN == 1
;;;352    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  492c              LDR      r1,|L14.180|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;353    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  482c              LDR      r0,|L14.184|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;354    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  482c              LDR      r0,|L14.188|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;355    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f6080          MOV      r0,#0x400
000012  8188              STRH     r0,[r1,#0xc]
;;;356    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;357    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;358    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;359    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;360    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;361    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;362    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;363    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;364    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;365    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;366    #endif
;;;367    
;;;368    #if UART2_FIFO_EN == 1
;;;369    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002a  4825              LDR      r0,|L14.192|
00002c  4925              LDR      r1,|L14.196|
00002e  6008              STR      r0,[r1,#0]  ; g_tUart2
;;;370    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000030  4825              LDR      r0,|L14.200|
000032  6048              STR      r0,[r1,#4]  ; g_tUart2
;;;371    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
000034  4825              LDR      r0,|L14.204|
000036  6088              STR      r0,[r1,#8]  ; g_tUart2
;;;372    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000038  2001              MOVS     r0,#1
00003a  8188              STRH     r0,[r1,#0xc]
;;;373    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00003c  02c0              LSLS     r0,r0,#11
00003e  81c8              STRH     r0,[r1,#0xe]
;;;374    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000040  2000              MOVS     r0,#0
000042  8208              STRH     r0,[r1,#0x10]
;;;375    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000044  8248              STRH     r0,[r1,#0x12]
;;;376    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
000046  82c8              STRH     r0,[r1,#0x16]
;;;377    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
000048  8308              STRH     r0,[r1,#0x18]
;;;378    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004a  8348              STRH     r0,[r1,#0x1a]
;;;379    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */	
00004c  8288              STRH     r0,[r1,#0x14]
;;;380    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
00004e  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;381    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
000050  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;382    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000052  6248              STR      r0,[r1,#0x24]  ; g_tUart2
;;;383    #endif
;;;384    
;;;385    #if UART3_FIFO_EN == 1
;;;386    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
000054  481e              LDR      r0,|L14.208|
000056  491f              LDR      r1,|L14.212|
000058  6008              STR      r0,[r1,#0]  ; g_tUart3
;;;387    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
00005a  481f              LDR      r0,|L14.216|
00005c  6048              STR      r0,[r1,#4]  ; g_tUart3
;;;388    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
00005e  481f              LDR      r0,|L14.220|
000060  6088              STR      r0,[r1,#8]  ; g_tUart3
;;;389    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000062  f44f6080          MOV      r0,#0x400
000066  8188              STRH     r0,[r1,#0xc]
;;;390    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000068  81c8              STRH     r0,[r1,#0xe]
;;;391    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
00006a  2000              MOVS     r0,#0
00006c  8208              STRH     r0,[r1,#0x10]
;;;392    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
00006e  8248              STRH     r0,[r1,#0x12]
;;;393    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
000070  82c8              STRH     r0,[r1,#0x16]
;;;394    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
000072  8308              STRH     r0,[r1,#0x18]
;;;395    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
000074  8348              STRH     r0,[r1,#0x1a]
;;;396    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */	
000076  8288              STRH     r0,[r1,#0x14]
;;;397    	g_tUart3.SendBefor = USART3_SendBefor;		/* 发送数据前的回调函数 */
000078  4819              LDR      r0,|L14.224|
00007a  61c8              STR      r0,[r1,#0x1c]  ; g_tUart3
;;;398    	g_tUart3.SendOver = USART3_SendOver;		/* 发送完毕后的回调函数 */
00007c  4819              LDR      r0,|L14.228|
00007e  6208              STR      r0,[r1,#0x20]  ; g_tUart3
;;;399    	g_tUart3.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000080  2000              MOVS     r0,#0
000082  6248              STR      r0,[r1,#0x24]  ; g_tUart3
;;;400    #endif
;;;401    
;;;402    #if UART4_FIFO_EN == 1
;;;403    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;404    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;405    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;406    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;407    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;408    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;409    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;410    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;411    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;412    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;413    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */	
;;;414    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;415    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;416    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;417    #endif
;;;418    
;;;419    #if UART5_FIFO_EN == 1
;;;420    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;421    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;422    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;423    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;424    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;425    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;426    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;427    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;428    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;429    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;430    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */	
;;;431    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;432    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;433    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;434    #endif
;;;435    
;;;436    
;;;437    #if UART6_FIFO_EN == 1
;;;438    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
000084  4818              LDR      r0,|L14.232|
000086  4919              LDR      r1,|L14.236|
000088  6008              STR      r0,[r1,#0]  ; g_tUart6
;;;439    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
00008a  4819              LDR      r0,|L14.240|
00008c  6048              STR      r0,[r1,#4]  ; g_tUart6
;;;440    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
00008e  4819              LDR      r0,|L14.244|
000090  6088              STR      r0,[r1,#8]  ; g_tUart6
;;;441    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000092  f44f6080          MOV      r0,#0x400
000096  8188              STRH     r0,[r1,#0xc]
;;;442    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000098  81c8              STRH     r0,[r1,#0xe]
;;;443    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
00009a  2000              MOVS     r0,#0
00009c  8208              STRH     r0,[r1,#0x10]
;;;444    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
00009e  8248              STRH     r0,[r1,#0x12]
;;;445    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
0000a0  82c8              STRH     r0,[r1,#0x16]
;;;446    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
0000a2  8308              STRH     r0,[r1,#0x18]
;;;447    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
0000a4  8348              STRH     r0,[r1,#0x1a]
;;;448    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */	
0000a6  8288              STRH     r0,[r1,#0x14]
;;;449    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
0000a8  61c8              STR      r0,[r1,#0x1c]  ; g_tUart6
;;;450    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
0000aa  6208              STR      r0,[r1,#0x20]  ; g_tUart6
;;;451    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
0000ac  6248              STR      r0,[r1,#0x24]  ; g_tUart6
;;;452    #endif
;;;453    }
0000ae  4770              BX       lr
;;;454    
                          ENDP

                  |L14.176|
                          DCD      0x40011000
                  |L14.180|
                          DCD      g_tUart1
                  |L14.184|
                          DCD      g_TxBuf1
                  |L14.188|
                          DCD      g_RxBuf1
                  |L14.192|
                          DCD      0x40004400
                  |L14.196|
                          DCD      g_tUart2
                  |L14.200|
                          DCD      g_TxBuf2
                  |L14.204|
                          DCD      g_RxBuf2
                  |L14.208|
                          DCD      0x40004800
                  |L14.212|
                          DCD      g_tUart3
                  |L14.216|
                          DCD      g_TxBuf3
                  |L14.220|
                          DCD      g_RxBuf3
                  |L14.224|
                          DCD      USART3_SendBefor
                  |L14.228|
                          DCD      USART3_SendOver
                  |L14.232|
                          DCD      0x40011400
                  |L14.236|
                          DCD      g_tUart6
                  |L14.240|
                          DCD      g_TxBuf6
                  |L14.244|
                          DCD      g_RxBuf6

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;193     */
;;;194    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;195    {
;;;196      register uint32_t __regPriMask         __ASM("primask");
;;;197      __regPriMask = (priMask);
;;;198    }
000004  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;78     */
;;;79     void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;82     
;;;83     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;84     
;;;85     	ConfigUartNVIC();	/* 配置串口中断 */
00000a  f7fffffe          BL       ConfigUartNVIC
;;;86     }
00000e  bd10              POP      {r4,pc}
;;;87     
                          ENDP


                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;295    */
;;;296    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;297    {
000002  4603              MOV      r3,r0
;;;298    	UART_T *pUart;
;;;299    
;;;300    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;301    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L17.16|
                  |L17.14|
;;;302    	{
;;;303    		return;
;;;304    	}
;;;305    
;;;306    	pUart->usRxWrite = 0;
;;;307    	pUart->usRxRead = 0;
;;;308    	pUart->usRxCount = 0;
;;;309    }
00000e  bd00              POP      {pc}
                  |L17.16|
000010  2000              MOVS     r0,#0                 ;306
000012  82d0              STRH     r0,[r2,#0x16]         ;306
000014  8310              STRH     r0,[r2,#0x18]         ;307
000016  8350              STRH     r0,[r2,#0x1a]         ;308
000018  bf00              NOP      
00001a  e7f8              B        |L17.14|
;;;310    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;272    */
;;;273    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;274    {
000002  4603              MOV      r3,r0
;;;275    	UART_T *pUart;
;;;276    
;;;277    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;278    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L18.16|
                  |L18.14|
;;;279    	{
;;;280    		return;
;;;281    	}
;;;282    
;;;283    	pUart->usTxWrite = 0;
;;;284    	pUart->usTxRead = 0;
;;;285    	pUart->usTxCount = 0;
;;;286    }
00000e  bd00              POP      {pc}
                  |L18.16|
000010  2000              MOVS     r0,#0                 ;283
000012  8210              STRH     r0,[r2,#0x10]         ;283
000014  8250              STRH     r0,[r2,#0x12]         ;284
000016  8290              STRH     r0,[r2,#0x14]         ;285
000018  bf00              NOP      
00001a  e7f8              B        |L18.14|
;;;287    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;251    */
;;;252    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;253    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;254    	UART_T *pUart;
;;;255    
;;;256    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;257    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L19.20|
;;;258    	{
;;;259    		return 0;
000010  2000              MOVS     r0,#0
                  |L19.18|
;;;260    	}
;;;261    
;;;262    	return UartGetChar(pUart, _pByte);
;;;263    }
000012  bd70              POP      {r4-r6,pc}
                  |L19.20|
000014  4631              MOV      r1,r6                 ;262
000016  4620              MOV      r0,r4                 ;262
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L19.18|
;;;264    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;162    */
;;;163    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;164    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;165    	UART_T *pUart;
;;;166    
;;;167    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;168    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L20.24|
                  |L20.20|
;;;169    	{
;;;170    		return;
;;;171    	}
;;;172    
;;;173    	if (pUart->SendBefor != 0)
;;;174    	{
;;;175    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;176    	}
;;;177    
;;;178    	UartSend(pUart, _ucaBuf, _usLen);
;;;179    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L20.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;173
00001a  b108              CBZ      r0,|L20.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;175
00001e  4780              BLX      r0                    ;175
                  |L20.32|
000020  463a              MOV      r2,r7                 ;178
000022  4631              MOV      r1,r6                 ;178
000024  4620              MOV      r0,r4                 ;178
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L20.20|
;;;180    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;189    */
;;;190    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;191    {
000002  4604              MOV      r4,r0
;;;192    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;193    }
00000e  bd1c              POP      {r2-r4,pc}
;;;194    
                          ENDP


                          AREA ||i.comSendHalfword||, CODE, READONLY, ALIGN=1

                  comSendHalfword PROC
;;;195    //自己添加程序，若不对，可修改，发送两个字节
;;;196    void comSendHalfword(COM_PORT_E _ucPort, uint16_t _ucByte)
000000  b57c              PUSH     {r2-r6,lr}
;;;197    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;198    	uint8_t temp_h, temp_l;
;;;199    	
;;;200    	/* 取出高八位 */
;;;201    	temp_h = (_ucByte&0XFF00)>>8;
000006  0a20              LSRS     r0,r4,#8
000008  9001              STR      r0,[sp,#4]
;;;202    	/* 取出低八位 */
;;;203    	temp_l = _ucByte&0XFF;
00000a  b2e0              UXTB     r0,r4
00000c  9000              STR      r0,[sp,#0]
;;;204    	
;;;205    	
;;;206    	comSendBuf(_ucPort, &temp_h, 1);
00000e  2201              MOVS     r2,#1
000010  a901              ADD      r1,sp,#4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       comSendBuf
;;;207    	comSendBuf(_ucPort, &temp_l, 1);
000018  2201              MOVS     r2,#1
00001a  4669              MOV      r1,sp
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       comSendBuf
;;;208    
;;;209    }
000022  bd7c              POP      {r2-r6,pc}
;;;210    void comSendword(COM_PORT_E _ucPort, uint32_t _ucByte)
                          ENDP


                          AREA ||i.comSendword||, CODE, READONLY, ALIGN=1

                  comSendword PROC
;;;209    }
;;;210    void comSendword(COM_PORT_E _ucPort, uint32_t _ucByte)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;211    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;212    	uint16_t temp_h, temp_l;
;;;213    	
;;;214    	/* 取出高十六位 */
;;;215    	temp_h = (_ucByte&0XFFFF0000)>>16;
000008  0c26              LSRS     r6,r4,#16
;;;216    	/* 取出低十六位 */
;;;217    	temp_l = _ucByte&0XFFFF;
00000a  b2a7              UXTH     r7,r4
;;;218    	
;;;219    	comSendHalfword(_ucPort, temp_h);
00000c  4631              MOV      r1,r6
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       comSendHalfword
;;;220    	comSendHalfword(_ucPort, temp_l);
000014  4639              MOV      r1,r7
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       comSendHalfword
;;;221    //	comSendBuf(_ucPort, &temp_h, 1);
;;;222    //	comSendBuf(_ucPort, &temp_l, 1);
;;;223    
;;;224    }
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;225    //void comSendword(COM_PORT_E _ucPort, uint32_t _ucByte)
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1298   */
;;;1299   int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;1300   {
000002  4604              MOV      r4,r0
;;;1301   
;;;1302   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1303   	uint8_t ucData;
;;;1304   
;;;1305   	while(comGetChar(COM1, &ucData) == 0);
000004  bf00              NOP      
                  |L24.6|
000006  4669              MOV      r1,sp
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L24.6|
;;;1306   
;;;1307   	return ucData;
000012  f89d0000          LDRB     r0,[sp,#0]
;;;1308   #else
;;;1309   	/* 等待串口1输入数据 */
;;;1310   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1311   
;;;1312   	return (int)USART_ReceiveData(USART1);
;;;1313   #endif
;;;1314   }
000016  bd38              POP      {r3-r5,pc}
;;;1315   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1272   */
;;;1273   int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;1274   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1275   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1276   	comSendChar(COM1, ch);
000006  b2e1              UXTB     r1,r4
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       comSendChar
;;;1277   
;;;1278   	return ch;
00000e  4620              MOV      r0,r4
;;;1279   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1280   	/* 写一个字节到USART1 */
;;;1281   	USART_SendData(USART1, (uint8_t) ch);
;;;1282   
;;;1283   	/* 等待发送结束 */
;;;1284   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;1285   	{}
;;;1286   
;;;1287   	return ch;
;;;1288   #endif
;;;1289   }
000010  bd70              POP      {r4-r6,pc}
;;;1290   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024
                  g_tUart2
                          %        40
                  g_RxBuf2
                          %        2048
                  g_tUart3
                          %        40
                  g_TxBuf3
                          %        1024
                  g_RxBuf3
                          %        1024
                  g_tUart6
                          %        40
                  g_TxBuf6
                          %        1024
                  g_RxBuf6
                          %        1024

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_BUF
                          %        8
                  USART_RX_STA
000008  0000              DCW      0x0000
                  g_TxBuf2
00000a  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_7cc17ae7____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_7cc17ae7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_7cc17ae7____REVSH|
#line 144
|__asm___15_bsp_uart_fifo_c_7cc17ae7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
