; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ad7606.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ad7606.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\STM32_USB_HOST_Library\Class\MSC\inc -I..\..\Libraries\STM32_USB_HOST_Library\Core\inc -I..\..\Libraries\STM32_USB_OTG_Driver\inc -I..\..\User -I..\..\User\bsp_stm32f4xx -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\FatFS\src -I..\..\User\usbh_mass_storage -ID:\Software\keil\ARM\RV31\INC -ID:\Software\keil\ARM\CMSIS\Include -ID:\Software\keil\ARM\Inc\ST\STM32F4xx -D__MICROLIB -D__UVISION_VERSION=518 -DUSE_STDPERIPH_DRIVER -DSTM32F40XX -DUSE_USB_OTG_HS -DUSE_EMBEDDED_PHY --signed_chars --omf_browse=.\flash\obj\bsp_ad7606.crf ..\..\User\bsp_stm32f4xx\src\bsp_ad7606.c]
                          THUMB

                          AREA ||i.AD7606_CtrlLinesConfig||, CODE, READONLY, ALIGN=2

                  AD7606_CtrlLinesConfig PROC
;;;120    */
;;;121    static void AD7606_CtrlLinesConfig(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;122    {
;;;123    	GPIO_InitTypeDef GPIO_InitStructure;
;;;124    
;;;125    	/* 使能FSMC时钟 */
;;;126    	RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB3PeriphClockCmd
;;;127    
;;;128    	/* 使能 GPIO时钟 */
;;;129    	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOG, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2058              MOVS     r0,#0x58
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;130    
;;;131    	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;132    	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;133    
;;;134    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
000012  220c              MOVS     r2,#0xc
000014  2100              MOVS     r1,#0
000016  484d              LDR      r0,|L1.332|
000018  f7fffffe          BL       GPIO_PinAFConfig
;;;135    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
00001c  220c              MOVS     r2,#0xc
00001e  2101              MOVS     r1,#1
000020  484a              LDR      r0,|L1.332|
000022  f7fffffe          BL       GPIO_PinAFConfig
;;;136    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
000026  220c              MOVS     r2,#0xc
000028  2104              MOVS     r1,#4
00002a  4848              LDR      r0,|L1.332|
00002c  f7fffffe          BL       GPIO_PinAFConfig
;;;137    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
000030  220c              MOVS     r2,#0xc
000032  2105              MOVS     r1,#5
000034  4845              LDR      r0,|L1.332|
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;138    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
00003a  220c              MOVS     r2,#0xc
00003c  2108              MOVS     r1,#8
00003e  4843              LDR      r0,|L1.332|
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;139    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
000044  220c              MOVS     r2,#0xc
000046  2109              MOVS     r1,#9
000048  4840              LDR      r0,|L1.332|
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;140    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
00004e  220c              MOVS     r2,#0xc
000050  210a              MOVS     r1,#0xa
000052  483e              LDR      r0,|L1.332|
000054  f7fffffe          BL       GPIO_PinAFConfig
;;;141    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
000058  220c              MOVS     r2,#0xc
00005a  210e              MOVS     r1,#0xe
00005c  483b              LDR      r0,|L1.332|
00005e  f7fffffe          BL       GPIO_PinAFConfig
;;;142    	GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
000062  220c              MOVS     r2,#0xc
000064  210f              MOVS     r1,#0xf
000066  4839              LDR      r0,|L1.332|
000068  f7fffffe          BL       GPIO_PinAFConfig
;;;143    
;;;144    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
00006c  f24c7033          MOV      r0,#0xc733
000070  9000              STR      r0,[sp,#0]
;;;145    	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;146    	                            GPIO_Pin_15;
;;;147    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000072  2002              MOVS     r0,#2
000074  f88d0004          STRB     r0,[sp,#4]
;;;148    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000078  2003              MOVS     r0,#3
00007a  f88d0005          STRB     r0,[sp,#5]
;;;149    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00007e  2000              MOVS     r0,#0
000080  f88d0006          STRB     r0,[sp,#6]
;;;150    	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000084  f88d0007          STRB     r0,[sp,#7]
;;;151    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000088  4669              MOV      r1,sp
00008a  4830              LDR      r0,|L1.332|
00008c  f7fffffe          BL       GPIO_Init
;;;152    
;;;153    	/*
;;;154    		PE4/FSMC_A20		--- 和主片选一起译码
;;;155    		PE5/FSMC_A21		--- 和主片选一起译码
;;;156    
;;;157    		PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;158    	 	PE.14(D11), PE.15(D12)
;;;159    	*/
;;;160    //	GPIO_PinAFConfig(GPIOE, GPIO_PinSource4 , GPIO_AF_FSMC);
;;;161    //	GPIO_PinAFConfig(GPIOE, GPIO_PinSource5 , GPIO_AF_FSMC);
;;;162    
;;;163    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource7 , GPIO_AF_FSMC);
000090  220c              MOVS     r2,#0xc
000092  2107              MOVS     r1,#7
000094  482e              LDR      r0,|L1.336|
000096  f7fffffe          BL       GPIO_PinAFConfig
;;;164    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource8 , GPIO_AF_FSMC);
00009a  220c              MOVS     r2,#0xc
00009c  2108              MOVS     r1,#8
00009e  482c              LDR      r0,|L1.336|
0000a0  f7fffffe          BL       GPIO_PinAFConfig
;;;165    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource9 , GPIO_AF_FSMC);
0000a4  220c              MOVS     r2,#0xc
0000a6  2109              MOVS     r1,#9
0000a8  4829              LDR      r0,|L1.336|
0000aa  f7fffffe          BL       GPIO_PinAFConfig
;;;166    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource10 , GPIO_AF_FSMC);
0000ae  220c              MOVS     r2,#0xc
0000b0  210a              MOVS     r1,#0xa
0000b2  4827              LDR      r0,|L1.336|
0000b4  f7fffffe          BL       GPIO_PinAFConfig
;;;167    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource11 , GPIO_AF_FSMC);
0000b8  220c              MOVS     r2,#0xc
0000ba  210b              MOVS     r1,#0xb
0000bc  4824              LDR      r0,|L1.336|
0000be  f7fffffe          BL       GPIO_PinAFConfig
;;;168    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource12 , GPIO_AF_FSMC);
0000c2  220c              MOVS     r2,#0xc
0000c4  4611              MOV      r1,r2
0000c6  4822              LDR      r0,|L1.336|
0000c8  f7fffffe          BL       GPIO_PinAFConfig
;;;169    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource13 , GPIO_AF_FSMC);
0000cc  220c              MOVS     r2,#0xc
0000ce  210d              MOVS     r1,#0xd
0000d0  481f              LDR      r0,|L1.336|
0000d2  f7fffffe          BL       GPIO_PinAFConfig
;;;170    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource14 , GPIO_AF_FSMC);
0000d6  220c              MOVS     r2,#0xc
0000d8  210e              MOVS     r1,#0xe
0000da  481d              LDR      r0,|L1.336|
0000dc  f7fffffe          BL       GPIO_PinAFConfig
;;;171    	GPIO_PinAFConfig(GPIOE, GPIO_PinSource15 , GPIO_AF_FSMC);
0000e0  220c              MOVS     r2,#0xc
0000e2  210f              MOVS     r1,#0xf
0000e4  481a              LDR      r0,|L1.336|
0000e6  f7fffffe          BL       GPIO_PinAFConfig
;;;172    
;;;173    //	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
;;;174    //	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;175    //	                            GPIO_Pin_15;
;;;176    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
0000ea  f64f7080          MOV      r0,#0xff80
0000ee  9000              STR      r0,[sp,#0]
;;;177    	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;178    	                            GPIO_Pin_15;
;;;179    	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000f0  4669              MOV      r1,sp
0000f2  4817              LDR      r0,|L1.336|
0000f4  f7fffffe          BL       GPIO_Init
;;;180    
;;;181    	/* 设置 PG12  为复用推挽输出 */
;;;182    	GPIO_PinAFConfig(GPIOG, GPIO_PinSource12, GPIO_AF_FSMC);
0000f8  220c              MOVS     r2,#0xc
0000fa  4611              MOV      r1,r2
0000fc  4815              LDR      r0,|L1.340|
0000fe  f7fffffe          BL       GPIO_PinAFConfig
;;;183    
;;;184    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000102  f44f5080          MOV      r0,#0x1000
000106  9000              STR      r0,[sp,#0]
;;;185    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000108  4669              MOV      r1,sp
00010a  4812              LDR      r0,|L1.340|
00010c  f7fffffe          BL       GPIO_Init
;;;186    
;;;187    	/*	配置几个控制用的GPIO
;;;188    		PH9/DCMI_D0/AD7606_OS0			---> AD7606_OS0		OS2:OS0 选择数字滤波参数
;;;189    		PH10/DCMI_D1/AD7606_OS1         ---> AD7606_OS1
;;;190    		PH11/DCMI_D2/AD7606_OS2         ---> AD7606_OS2
;;;191    		PH12/DCMI_D3/AD7606_CONVST      ---> AD7606_CONVST	启动ADC转换
;;;192    		PH14/DCMI_D4/AD7606_RAGE        ---> AD7606_RAGE	输入模拟电压量程，正负5V或正负10V
;;;193    		PI4/DCMI_D5/AD7606_RESET        ---> AD7606_RESET	复位
;;;194    
;;;195    		PI6/DCMI_D6/AD7606_BUSY			---> AD7606_BUSY    转换结束的信号
;;;196    	*/
;;;197    	{
;;;198    		/* 使能 GPIO时钟 */
;;;199    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH | RCC_AHB1Periph_GPIOI, ENABLE);
000110  2101              MOVS     r1,#1
000112  f44f70c0          MOV      r0,#0x180
000116  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;200    
;;;201    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
00011a  2001              MOVS     r0,#1
00011c  f88d0004          STRB     r0,[sp,#4]
;;;202    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000120  2003              MOVS     r0,#3
000122  f88d0005          STRB     r0,[sp,#5]
;;;203    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000126  2000              MOVS     r0,#0
000128  f88d0006          STRB     r0,[sp,#6]
;;;204    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
00012c  f88d0007          STRB     r0,[sp,#7]
;;;205    
;;;206    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_14;
000130  f44f40bc          MOV      r0,#0x5e00
000134  9000              STR      r0,[sp,#0]
;;;207    		GPIO_Init(GPIOH, &GPIO_InitStructure);
000136  4669              MOV      r1,sp
000138  4807              LDR      r0,|L1.344|
00013a  f7fffffe          BL       GPIO_Init
;;;208    
;;;209    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00013e  2010              MOVS     r0,#0x10
000140  9000              STR      r0,[sp,#0]
;;;210    		GPIO_Init(GPIOI, &GPIO_InitStructure);
000142  4669              MOV      r1,sp
000144  4805              LDR      r0,|L1.348|
000146  f7fffffe          BL       GPIO_Init
;;;211    	}
;;;212    }
00014a  bd1c              POP      {r2-r4,pc}
;;;213    
                          ENDP

                  |L1.332|
                          DCD      0x40020c00
                  |L1.336|
                          DCD      0x40021000
                  |L1.340|
                          DCD      0x40021800
                  |L1.344|
                          DCD      0x40021c00
                  |L1.348|
                          DCD      0x40022000

                          AREA ||i.AD7606_EnterAutoMode||, CODE, READONLY, ALIGN=2

                  AD7606_EnterAutoMode PROC
;;;444    */
;;;445    void AD7606_EnterAutoMode(uint32_t _ulFreq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;446    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
;;;447    	/* 配置PH12为复用功能，TIM5_CH3 . 执行后bsp_InitAD7606()对PH2口线的配置将失效 */
;;;448    	{
;;;449    		GPIO_InitTypeDef GPIO_InitStructure;
;;;450    
;;;451    		/* TIM5 clock enable */
;;;452    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
000006  2101              MOVS     r1,#1
000008  2008              MOVS     r0,#8
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;453    
;;;454    		/* GPIOH clock enable */
;;;455    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2080              MOVS     r0,#0x80
000012  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;456    
;;;457    		/* GPIOH Configuration: PH12  -> TIM5 CH3 */
;;;458    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000016  f44f5080          MOV      r0,#0x1000
00001a  9007              STR      r0,[sp,#0x1c]
;;;459    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00001c  2002              MOVS     r0,#2
00001e  f88d0020          STRB     r0,[sp,#0x20]
;;;460    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000022  2003              MOVS     r0,#3
000024  f88d0021          STRB     r0,[sp,#0x21]
;;;461    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000028  2000              MOVS     r0,#0
00002a  f88d0022          STRB     r0,[sp,#0x22]
;;;462    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
00002e  2001              MOVS     r0,#1
000030  f88d0023          STRB     r0,[sp,#0x23]
;;;463    		GPIO_Init(GPIOH, &GPIO_InitStructure);
000034  a907              ADD      r1,sp,#0x1c
000036  483c              LDR      r0,|L2.296|
000038  f7fffffe          BL       GPIO_Init
;;;464    
;;;465    		/* Connect TIM5 pins to AF2 */
;;;466    		GPIO_PinAFConfig(GPIOH, GPIO_PinSource12, GPIO_AF_TIM5);
00003c  2202              MOVS     r2,#2
00003e  210c              MOVS     r1,#0xc
000040  4839              LDR      r0,|L2.296|
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;467    	}
;;;468    
;;;469    	{
;;;470    		TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;471    		TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;472    		uint32_t uiTIMxCLK;
;;;473    		uint16_t usPrescaler;
;;;474    		uint16_t usPeriod;
;;;475    
;;;476    		//TIM_DeInit(TIM5);	/* 复位TIM定时器 */
;;;477    
;;;478    	    /*-----------------------------------------------------------------------
;;;479    			system_stm32f4xx.c 文件中 void SetSysClock(void) 函数对时钟的配置如下：
;;;480    
;;;481    			HCLK = SYSCLK / 1     (AHB1Periph)
;;;482    			PCLK2 = HCLK / 2      (APB2Periph)
;;;483    			PCLK1 = HCLK / 4      (APB1Periph)
;;;484    
;;;485    			因为APB1 prescaler != 1, 所以 APB1上的TIMxCLK = PCLK1 x 2 = SystemCoreClock / 2;
;;;486    			因为APB2 prescaler != 1, 所以 APB2上的TIMxCLK = PCLK2 x 2 = SystemCoreClock;
;;;487    
;;;488    			APB1 定时器有 TIM2, TIM3 ,TIM4, TIM5, TIM6, TIM6, TIM12, TIM13,TIM14
;;;489    			APB2 定时器有 TIM1, TIM8 ,TIM9, TIM10, TIM11
;;;490    		*/
;;;491    
;;;492    		uiTIMxCLK = SystemCoreClock / 2;
000046  4839              LDR      r0,|L2.300|
000048  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00004a  0847              LSRS     r7,r0,#1
;;;493    
;;;494    		if (_ulFreq < 3000)
00004c  f64030b8          MOV      r0,#0xbb8
000050  4284              CMP      r4,r0
000052  d208              BCS      |L2.102|
;;;495    		{
;;;496    			usPrescaler = 100 - 1;					/* 分频比 = 10 */
000054  2563              MOVS     r5,#0x63
;;;497    			usPeriod =  (uiTIMxCLK / 100) / _ulFreq  - 1;		/* 自动重装的值 */
000056  2064              MOVS     r0,#0x64
000058  fbb7f0f0          UDIV     r0,r7,r0
00005c  fbb0f0f4          UDIV     r0,r0,r4
000060  1e40              SUBS     r0,r0,#1
000062  b286              UXTH     r6,r0
000064  e004              B        |L2.112|
                  |L2.102|
;;;498    		}
;;;499    		else	/* 大于4K的频率，无需分频 */
;;;500    		{
;;;501    			usPrescaler = 0;					/* 分频比 = 1 */
000066  2500              MOVS     r5,#0
;;;502    			usPeriod = uiTIMxCLK / _ulFreq - 1;	/* 自动重装的值 */
000068  fbb7f0f4          UDIV     r0,r7,r4
00006c  1e40              SUBS     r0,r0,#1
00006e  b286              UXTH     r6,r0
                  |L2.112|
;;;503    		}
;;;504    
;;;505    		/* Time base configuration */
;;;506    		TIM_TimeBaseStructure.TIM_Period = usPeriod;
000070  9607              STR      r6,[sp,#0x1c]
;;;507    		TIM_TimeBaseStructure.TIM_Prescaler = usPrescaler;
000072  f8ad5018          STRH     r5,[sp,#0x18]
;;;508    		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000076  2000              MOVS     r0,#0
000078  f8ad0020          STRH     r0,[sp,#0x20]
;;;509    		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00007c  f8ad001a          STRH     r0,[sp,#0x1a]
;;;510    
;;;511    		TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
000080  a906              ADD      r1,sp,#0x18
000082  482b              LDR      r0,|L2.304|
000084  f7fffffe          BL       TIM_TimeBaseInit
;;;512    
;;;513    		/* PWM1 Mode configuration: Channel1 */
;;;514    		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
000088  2060              MOVS     r0,#0x60
00008a  f8ad0004          STRH     r0,[sp,#4]
;;;515    		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
00008e  2001              MOVS     r0,#1
000090  f8ad0006          STRH     r0,[sp,#6]
;;;516    		TIM_OCInitStructure.TIM_Pulse = 4;
000094  2004              MOVS     r0,#4
000096  9003              STR      r0,[sp,#0xc]
;;;517    		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
000098  2002              MOVS     r0,#2
00009a  f8ad0010          STRH     r0,[sp,#0x10]
;;;518    
;;;519    		TIM_OC3Init(TIM5, &TIM_OCInitStructure);
00009e  a901              ADD      r1,sp,#4
0000a0  4823              LDR      r0,|L2.304|
0000a2  f7fffffe          BL       TIM_OC3Init
;;;520    
;;;521    		TIM_OC3PreloadConfig(TIM5, TIM_OCPreload_Enable);
0000a6  2108              MOVS     r1,#8
0000a8  4821              LDR      r0,|L2.304|
0000aa  f7fffffe          BL       TIM_OC3PreloadConfig
;;;522    
;;;523    		TIM_ARRPreloadConfig(TIM5, ENABLE);
0000ae  2101              MOVS     r1,#1
0000b0  481f              LDR      r0,|L2.304|
0000b2  f7fffffe          BL       TIM_ARRPreloadConfig
;;;524    
;;;525    		TIM_Cmd(TIM5, ENABLE);
0000b6  2101              MOVS     r1,#1
0000b8  481d              LDR      r0,|L2.304|
0000ba  f7fffffe          BL       TIM_Cmd
;;;526    	}
;;;527    
;;;528    	/* 配置PI6, BUSY 作为中断输入口，下降沿触发 */
;;;529    	{
;;;530    		EXTI_InitTypeDef   EXTI_InitStructure;
;;;531    		GPIO_InitTypeDef   GPIO_InitStructure;
;;;532    		NVIC_InitTypeDef   NVIC_InitStructure;
;;;533    
;;;534    		/* Enable GPIOA clock */
;;;535    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOI, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  0208              LSLS     r0,r1,#8
0000c2  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;536    		/* Enable SYSCFG clock */
;;;537    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
0000c6  2101              MOVS     r1,#1
0000c8  0388              LSLS     r0,r1,#14
0000ca  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;538    
;;;539    		/* Configure PI6 pin as input floating */
;;;540    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
0000ce  2000              MOVS     r0,#0
0000d0  f88d0018          STRB     r0,[sp,#0x18]
;;;541    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
0000d4  f88d001b          STRB     r0,[sp,#0x1b]
;;;542    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
0000d8  2040              MOVS     r0,#0x40
0000da  9005              STR      r0,[sp,#0x14]
;;;543    		GPIO_Init(GPIOI, &GPIO_InitStructure);
0000dc  a905              ADD      r1,sp,#0x14
0000de  4815              LDR      r0,|L2.308|
0000e0  f7fffffe          BL       GPIO_Init
;;;544    
;;;545    		/* Connect EXTI Line6 to PI6 pin */
;;;546    		SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOI, EXTI_PinSource6);
0000e4  2106              MOVS     r1,#6
0000e6  2008              MOVS     r0,#8
0000e8  f7fffffe          BL       SYSCFG_EXTILineConfig
;;;547    
;;;548    		/* Configure EXTI Line6 */
;;;549    		EXTI_InitStructure.EXTI_Line = EXTI_Line6;
0000ec  2040              MOVS     r0,#0x40
0000ee  9007              STR      r0,[sp,#0x1c]
;;;550    		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
0000f0  2000              MOVS     r0,#0
0000f2  f88d0020          STRB     r0,[sp,#0x20]
;;;551    		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
0000f6  200c              MOVS     r0,#0xc
0000f8  f88d0021          STRB     r0,[sp,#0x21]
;;;552    
;;;553    		//EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
;;;554    		EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0000fc  2001              MOVS     r0,#1
0000fe  f88d0022          STRB     r0,[sp,#0x22]
;;;555    		EXTI_Init(&EXTI_InitStructure);
000102  a807              ADD      r0,sp,#0x1c
000104  f7fffffe          BL       EXTI_Init
;;;556    
;;;557    		/* Enable and set EXTI Line6 Interrupt to the lowest priority */
;;;558    		NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
000108  2017              MOVS     r0,#0x17
00010a  f88d0010          STRB     r0,[sp,#0x10]
;;;559    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
00010e  2000              MOVS     r0,#0
000110  f88d0011          STRB     r0,[sp,#0x11]
;;;560    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
000114  f88d0012          STRB     r0,[sp,#0x12]
;;;561    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000118  2001              MOVS     r0,#1
00011a  f88d0013          STRB     r0,[sp,#0x13]
;;;562    		NVIC_Init(&NVIC_InitStructure);
00011e  a804              ADD      r0,sp,#0x10
000120  f7fffffe          BL       NVIC_Init
;;;563    	}
;;;564    }
000124  b009              ADD      sp,sp,#0x24
000126  bdf0              POP      {r4-r7,pc}
;;;565    
                          ENDP

                  |L2.296|
                          DCD      0x40021c00
                  |L2.300|
                          DCD      SystemCoreClock
                  |L2.304|
                          DCD      0x40000c00
                  |L2.308|
                          DCD      0x40022000

                          AREA ||i.AD7606_FSMCConfig||, CODE, READONLY, ALIGN=1

                  AD7606_FSMCConfig PROC
;;;221    */
;;;222    static void AD7606_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;223    {
000002  b097              SUB      sp,sp,#0x5c
;;;224    	FSMC_NORSRAMInitTypeDef  init;
;;;225    	FSMC_NORSRAMTimingInitTypeDef  timing;
;;;226    
;;;227    	/*
;;;228    		AD7606规格书要求(3.3V时)：RD读信号低电平脉冲宽度最短21ns，高电平脉冲最短宽度15ns。
;;;229    
;;;230    		按照如下配置 读数均正常。为了和同BANK的LCD配置相同，选择3-0-6-1-0-0
;;;231    		3-0-5-1-0-0  : RD高持续75ns， 低电平持续50ns.  1us以内可读取8路样本数据到内存。
;;;232    		1-0-1-1-0-0  : RD高75ns，低电平执行12ns左右，下降沿差不多也12ns.  数据读取正确。
;;;233    	*/
;;;234    	/* FSMC_Bank1_NORSRAM4 configuration */
;;;235    	timing.FSMC_AddressSetupTime = 3;
000004  2003              MOVS     r0,#3
000006  9001              STR      r0,[sp,#4]
;;;236    	timing.FSMC_AddressHoldTime = 0;
000008  2000              MOVS     r0,#0
00000a  9002              STR      r0,[sp,#8]
;;;237    	timing.FSMC_DataSetupTime = 6;
00000c  2006              MOVS     r0,#6
00000e  9003              STR      r0,[sp,#0xc]
;;;238    	timing.FSMC_BusTurnAroundDuration = 1;
000010  2001              MOVS     r0,#1
000012  9004              STR      r0,[sp,#0x10]
;;;239    	timing.FSMC_CLKDivision = 0;
000014  2000              MOVS     r0,#0
000016  9005              STR      r0,[sp,#0x14]
;;;240    	timing.FSMC_DataLatency = 0;
000018  9006              STR      r0,[sp,#0x18]
;;;241    	timing.FSMC_AccessMode = FSMC_AccessMode_A;
00001a  9007              STR      r0,[sp,#0x1c]
;;;242    
;;;243    	/*
;;;244    	 LCD configured as follow:
;;;245    	    - Data/Address MUX = Disable
;;;246    	    - Memory Type = SRAM
;;;247    	    - Data Width = 16bit
;;;248    	    - Write Operation = Enable
;;;249    	    - Extended Mode = Enable
;;;250    	    - Asynchronous Wait = Disable
;;;251    	*/
;;;252    	init.FSMC_Bank = FSMC_Bank1_NORSRAM4;
00001c  2006              MOVS     r0,#6
00001e  9008              STR      r0,[sp,#0x20]
;;;253    	init.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
000020  2000              MOVS     r0,#0
000022  9009              STR      r0,[sp,#0x24]
;;;254    	init.FSMC_MemoryType = FSMC_MemoryType_SRAM;
000024  900a              STR      r0,[sp,#0x28]
;;;255    	init.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
000026  2010              MOVS     r0,#0x10
000028  900b              STR      r0,[sp,#0x2c]
;;;256    	init.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00002a  2000              MOVS     r0,#0
00002c  900c              STR      r0,[sp,#0x30]
;;;257    	init.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00002e  900d              STR      r0,[sp,#0x34]
;;;258    	init.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000030  900e              STR      r0,[sp,#0x38]
;;;259    	init.FSMC_WrapMode = FSMC_WrapMode_Disable;
000032  900f              STR      r0,[sp,#0x3c]
;;;260    	init.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
000034  9010              STR      r0,[sp,#0x40]
;;;261    	init.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000036  f44f5080          MOV      r0,#0x1000
00003a  9011              STR      r0,[sp,#0x44]
;;;262    	init.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
00003c  2000              MOVS     r0,#0
00003e  9012              STR      r0,[sp,#0x48]
;;;263    	init.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000040  9013              STR      r0,[sp,#0x4c]
;;;264    	init.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000042  9014              STR      r0,[sp,#0x50]
;;;265    
;;;266    	init.FSMC_ReadWriteTimingStruct = &timing;
000044  a801              ADD      r0,sp,#4
000046  9015              STR      r0,[sp,#0x54]
;;;267    	init.FSMC_WriteTimingStruct = &timing;
000048  9016              STR      r0,[sp,#0x58]
;;;268    
;;;269    	FSMC_NORSRAMInit(&init);
00004a  a808              ADD      r0,sp,#0x20
00004c  f7fffffe          BL       FSMC_NORSRAMInit
;;;270    
;;;271    	/* - BANK 1 (of NOR/SRAM Bank 1~4) is enabled */
;;;272    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
000050  2101              MOVS     r1,#1
000052  2006              MOVS     r0,#6
000054  f7fffffe          BL       FSMC_NORSRAMCmd
;;;273    }
000058  b017              ADD      sp,sp,#0x5c
00005a  bd00              POP      {pc}
;;;274    
                          ENDP


                          AREA ||i.AD7606_ISR||, CODE, READONLY, ALIGN=2

                  AD7606_ISR PROC
;;;637    
;;;638    void AD7606_ISR(void)
000000  b500              PUSH     {lr}
;;;639    {
;;;640    	AD7606_ReadNowAdc();
000002  f7fffffe          BL       AD7606_ReadNowAdc
;;;641    	biaozhi = 1;
000006  2001              MOVS     r0,#1
000008  4901              LDR      r1,|L4.16|
00000a  7008              STRB     r0,[r1,#0]
;;;642    	
;;;643    }
00000c  bd00              POP      {pc}
;;;644    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      biaozhi

                          AREA ||i.AD7606_ReadNowAdc||, CODE, READONLY, ALIGN=2

                  AD7606_ReadNowAdc PROC
;;;411    */
;;;412    void AD7606_ReadNowAdc(void)
000000  f04f40d8          MOV      r0,#0x6c000000
;;;413    {
;;;414    	g_tAD7606.sNowAdc[0] = AD7606_RESULT();	/* 读第1路样本 */
000004  8800              LDRH     r0,[r0,#0]
000006  b200              SXTH     r0,r0
000008  4916              LDR      r1,|L5.100|
00000a  8048              STRH     r0,[r1,#2]
;;;415    	g_tAD7606.sNowAdc[1] = AD7606_RESULT();	/* 读第2路样本 */
00000c  f04f40d8          MOV      r0,#0x6c000000
000010  8800              LDRH     r0,[r0,#0]
000012  b201              SXTH     r1,r0
000014  4813              LDR      r0,|L5.100|
000016  8081              STRH     r1,[r0,#4]
;;;416    	g_tAD7606.sNowAdc[2] = AD7606_RESULT();	/* 读第3路样本 */
000018  f04f40d8          MOV      r0,#0x6c000000
00001c  8800              LDRH     r0,[r0,#0]
00001e  b201              SXTH     r1,r0
000020  4810              LDR      r0,|L5.100|
000022  80c1              STRH     r1,[r0,#6]
;;;417    	g_tAD7606.sNowAdc[3] = AD7606_RESULT();	/* 读第4路样本 */
000024  f04f40d8          MOV      r0,#0x6c000000
000028  8800              LDRH     r0,[r0,#0]
00002a  b201              SXTH     r1,r0
00002c  480d              LDR      r0,|L5.100|
00002e  8101              STRH     r1,[r0,#8]
;;;418    	g_tAD7606.sNowAdc[4] = AD7606_RESULT();	/* 读第5路样本 */
000030  f04f40d8          MOV      r0,#0x6c000000
000034  8800              LDRH     r0,[r0,#0]
000036  b201              SXTH     r1,r0
000038  480a              LDR      r0,|L5.100|
00003a  8141              STRH     r1,[r0,#0xa]
;;;419    	g_tAD7606.sNowAdc[5] = AD7606_RESULT();	/* 读第6路样本 */
00003c  f04f40d8          MOV      r0,#0x6c000000
000040  8800              LDRH     r0,[r0,#0]
000042  b201              SXTH     r1,r0
000044  4807              LDR      r0,|L5.100|
000046  8181              STRH     r1,[r0,#0xc]
;;;420    	g_tAD7606.sNowAdc[6] = AD7606_RESULT();	/* 读第7路样本 */
000048  f04f40d8          MOV      r0,#0x6c000000
00004c  8800              LDRH     r0,[r0,#0]
00004e  b201              SXTH     r1,r0
000050  4804              LDR      r0,|L5.100|
000052  81c1              STRH     r1,[r0,#0xe]
;;;421    	g_tAD7606.sNowAdc[7] = AD7606_RESULT();	/* 读第8路样本 */
000054  f04f40d8          MOV      r0,#0x6c000000
000058  8800              LDRH     r0,[r0,#0]
00005a  b201              SXTH     r1,r0
00005c  4801              LDR      r0,|L5.100|
00005e  8201              STRH     r1,[r0,#0x10]
;;;422    }
000060  4770              BX       lr
;;;423    
                          ENDP

000062  0000              DCW      0x0000
                  |L5.100|
                          DCD      g_tAD7606

                          AREA ||i.AD7606_Reset||, CODE, READONLY, ALIGN=2

                  AD7606_Reset PROC
;;;372    */
;;;373    void AD7606_Reset(void)
000000  2010              MOVS     r0,#0x10
;;;374    {
;;;375    	RESET_0();	/* 退出复位状态 */
000002  4904              LDR      r1,|L6.20|
000004  8348              STRH     r0,[r1,#0x1a]
;;;376    
;;;377    	RESET_1();	/* 进入复位状态 */
000006  8308              STRH     r0,[r1,#0x18]
;;;378    	RESET_1();	/* 仅用于延迟。 RESET复位高电平脉冲宽度最小50ns。 */
000008  8308              STRH     r0,[r1,#0x18]
;;;379    	RESET_1();
00000a  8308              STRH     r0,[r1,#0x18]
;;;380    	RESET_1();
00000c  8308              STRH     r0,[r1,#0x18]
;;;381    
;;;382    	RESET_0();	/* 退出复位状态 */
00000e  8348              STRH     r0,[r1,#0x1a]
;;;383    }
000010  4770              BX       lr
;;;384    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40022000

                          AREA ||i.AD7606_SetInputRange||, CODE, READONLY, ALIGN=2

                  AD7606_SetInputRange PROC
;;;350    */
;;;351    void AD7606_SetInputRange(uint8_t _ucRange)
000000  b938              CBNZ     r0,|L7.18|
;;;352    {
;;;353    	if (_ucRange == 0)
;;;354    	{
;;;355    		g_tAD7606.ucRange = 0;
000002  2100              MOVS     r1,#0
000004  4a07              LDR      r2,|L7.36|
000006  7051              STRB     r1,[r2,#1]
;;;356    		RANGE_0();	/* 设置为正负5V */
000008  f44f4180          MOV      r1,#0x4000
00000c  4a06              LDR      r2,|L7.40|
00000e  8011              STRH     r1,[r2,#0]
000010  e006              B        |L7.32|
                  |L7.18|
;;;357    	}
;;;358    	else
;;;359    	{
;;;360    		g_tAD7606.ucRange = 1;
000012  2101              MOVS     r1,#1
000014  4a03              LDR      r2,|L7.36|
000016  7051              STRB     r1,[r2,#1]
;;;361    		RANGE_1();	/* 设置为正负10V */
000018  0389              LSLS     r1,r1,#14
00001a  4a03              LDR      r2,|L7.40|
00001c  1e92              SUBS     r2,r2,#2
00001e  8011              STRH     r1,[r2,#0]
                  |L7.32|
;;;362    	}
;;;363    }
000020  4770              BX       lr
;;;364    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      g_tAD7606
                  |L7.40|
                          DCD      0x40021c1a

                          AREA ||i.AD7606_SetOS||, CODE, READONLY, ALIGN=2

                  AD7606_SetOS PROC
;;;291    */
;;;292    void AD7606_SetOS(uint8_t _ucOS)
000000  492c              LDR      r1,|L8.180|
;;;293    {
;;;294    	g_tAD7606.ucOS = _ucOS;
000002  7008              STRB     r0,[r1,#0]
;;;295    	switch (_ucOS)
000004  2807              CMP      r0,#7
000006  d246              BCS      |L8.150|
000008  e8dff000          TBB      [pc,r0]
00000c  46040e19          DCB      0x46,0x04,0x0e,0x19
000010  232e3a00          DCB      0x23,0x2e,0x3a,0x00
;;;296    	{
;;;297    		case AD_OS_X2:
;;;298    			OS2_0();
000014  f44f6100          MOV      r1,#0x800
000018  4a27              LDR      r2,|L8.184|
00001a  8011              STRH     r1,[r2,#0]
;;;299    			OS1_0();
00001c  1049              ASRS     r1,r1,#1
00001e  8011              STRH     r1,[r2,#0]
;;;300    			OS0_1();
000020  1049              ASRS     r1,r1,#1
000022  1e92              SUBS     r2,r2,#2
000024  8011              STRH     r1,[r2,#0]
;;;301    			break;
000026  e043              B        |L8.176|
;;;302    
;;;303    		case AD_OS_X4:
;;;304    			OS2_0();
000028  f44f6100          MOV      r1,#0x800
00002c  4a22              LDR      r2,|L8.184|
00002e  8011              STRH     r1,[r2,#0]
;;;305    			OS1_1();
000030  1049              ASRS     r1,r1,#1
000032  1e92              SUBS     r2,r2,#2
000034  8011              STRH     r1,[r2,#0]
;;;306    			OS0_0();
000036  1049              ASRS     r1,r1,#1
000038  1c92              ADDS     r2,r2,#2
00003a  8011              STRH     r1,[r2,#0]
;;;307    			break;
00003c  e038              B        |L8.176|
;;;308    
;;;309    		case AD_OS_X8:
;;;310    			OS2_0();
00003e  f44f6100          MOV      r1,#0x800
000042  4a1d              LDR      r2,|L8.184|
000044  8011              STRH     r1,[r2,#0]
;;;311    			OS1_1();
000046  1049              ASRS     r1,r1,#1
000048  1e92              SUBS     r2,r2,#2
00004a  8011              STRH     r1,[r2,#0]
;;;312    			OS0_1();
00004c  1049              ASRS     r1,r1,#1
00004e  8011              STRH     r1,[r2,#0]
;;;313    			break;
000050  e02e              B        |L8.176|
;;;314    
;;;315    		case AD_OS_X16:
;;;316    			OS2_1();
000052  f44f6100          MOV      r1,#0x800
000056  4a18              LDR      r2,|L8.184|
000058  1e92              SUBS     r2,r2,#2
00005a  8011              STRH     r1,[r2,#0]
;;;317    			OS1_0();
00005c  1049              ASRS     r1,r1,#1
00005e  1c92              ADDS     r2,r2,#2
000060  8011              STRH     r1,[r2,#0]
;;;318    			OS0_0();
000062  1049              ASRS     r1,r1,#1
000064  8011              STRH     r1,[r2,#0]
;;;319    			break;
000066  e023              B        |L8.176|
;;;320    
;;;321    		case AD_OS_X32:
;;;322    			OS2_1();
000068  f44f6100          MOV      r1,#0x800
00006c  4a12              LDR      r2,|L8.184|
00006e  1e92              SUBS     r2,r2,#2
000070  8011              STRH     r1,[r2,#0]
;;;323    			OS1_0();
000072  1049              ASRS     r1,r1,#1
000074  1c92              ADDS     r2,r2,#2
000076  8011              STRH     r1,[r2,#0]
;;;324    			OS0_1();
000078  1049              ASRS     r1,r1,#1
00007a  1e92              SUBS     r2,r2,#2
00007c  8011              STRH     r1,[r2,#0]
;;;325    			break;
00007e  e017              B        |L8.176|
;;;326    
;;;327    		case AD_OS_X64:
;;;328    			OS2_1();
000080  f44f6100          MOV      r1,#0x800
000084  4a0c              LDR      r2,|L8.184|
000086  1e92              SUBS     r2,r2,#2
000088  8011              STRH     r1,[r2,#0]
;;;329    			OS1_1();
00008a  1049              ASRS     r1,r1,#1
00008c  8011              STRH     r1,[r2,#0]
;;;330    			OS0_0();
00008e  1049              ASRS     r1,r1,#1
000090  1c92              ADDS     r2,r2,#2
000092  8011              STRH     r1,[r2,#0]
;;;331    			break;
000094  e00c              B        |L8.176|
                  |L8.150|
;;;332    
;;;333    		case AD_OS_NO:
000096  bf00              NOP      
;;;334    		default:
;;;335    			g_tAD7606.ucOS = AD_OS_NO;
000098  2100              MOVS     r1,#0
00009a  4a06              LDR      r2,|L8.180|
00009c  7011              STRB     r1,[r2,#0]
;;;336    			OS2_0();
00009e  f44f6100          MOV      r1,#0x800
0000a2  4a05              LDR      r2,|L8.184|
0000a4  8011              STRH     r1,[r2,#0]
;;;337    			OS1_0();
0000a6  1049              ASRS     r1,r1,#1
0000a8  8011              STRH     r1,[r2,#0]
;;;338    			OS0_0();
0000aa  1049              ASRS     r1,r1,#1
0000ac  8011              STRH     r1,[r2,#0]
;;;339    			break;
0000ae  bf00              NOP      
                  |L8.176|
0000b0  bf00              NOP                            ;301
;;;340    	}
;;;341    }
0000b2  4770              BX       lr
;;;342    
                          ENDP

                  |L8.180|
                          DCD      g_tAD7606
                  |L8.184|
                          DCD      0x40021c1a

                          AREA ||i.AD7606_StartConvst||, CODE, READONLY, ALIGN=2

                  AD7606_StartConvst PROC
;;;392    */
;;;393    void AD7606_StartConvst(void)
000000  f44f5080          MOV      r0,#0x1000
;;;394    {
;;;395    	/* page 7：  CONVST 高电平脉冲宽度和低电平脉冲宽度最短 25ns */
;;;396    	/* CONVST平时为高 */
;;;397    	CONVST_0();
000004  4903              LDR      r1,|L9.20|
000006  8008              STRH     r0,[r1,#0]
;;;398    	CONVST_0();
000008  8008              STRH     r0,[r1,#0]
;;;399    	CONVST_0();
00000a  8008              STRH     r0,[r1,#0]
;;;400    
;;;401    	CONVST_1();
00000c  1e89              SUBS     r1,r1,#2
00000e  8008              STRH     r0,[r1,#0]
;;;402    }
000010  4770              BX       lr
;;;403    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40021c1a

                          AREA ||i.AD7606_StartRecord||, CODE, READONLY, ALIGN=1

                  AD7606_StartRecord PROC
;;;574    */
;;;575    void AD7606_StartRecord(uint32_t _ulFreq)
000000  b510              PUSH     {r4,lr}
;;;576    {
000002  4604              MOV      r4,r0
;;;577    	AD7606_StopRecord();
000004  f7fffffe          BL       AD7606_StopRecord
;;;578    
;;;579    	AD7606_Reset();					/* 复位硬件 */
000008  f7fffffe          BL       AD7606_Reset
;;;580    	AD7606_StartConvst();			/* 启动采样，避免第1组数据全0的问题 */
00000c  f7fffffe          BL       AD7606_StartConvst
;;;581    	AD7606_EnterAutoMode(_ulFreq);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       AD7606_EnterAutoMode
;;;582    }
000016  bd10              POP      {r4,pc}
;;;583    
                          ENDP


                          AREA ||i.AD7606_StopRecord||, CODE, READONLY, ALIGN=2

                  AD7606_StopRecord PROC
;;;591    */
;;;592    void AD7606_StopRecord(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;593    {
;;;594    	TIM_Cmd(TIM5, DISABLE);
000002  2100              MOVS     r1,#0
000004  4816              LDR      r0,|L11.96|
000006  f7fffffe          BL       TIM_Cmd
;;;595    
;;;596    	/* 将PH12 重新配置为普通输出口 */
;;;597    	{
;;;598    		GPIO_InitTypeDef GPIO_InitStructure;
;;;599    
;;;600    		/* 使能 GPIO时钟 */
;;;601    		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOH, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  2080              MOVS     r0,#0x80
00000e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;602    
;;;603    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000012  2001              MOVS     r0,#1
000014  f88d0004          STRB     r0,[sp,#4]
;;;604    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0005          STRB     r0,[sp,#5]
;;;605    		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001e  2000              MOVS     r0,#0
000020  f88d0006          STRB     r0,[sp,#6]
;;;606    		GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
000024  f88d0007          STRB     r0,[sp,#7]
;;;607    
;;;608    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000028  f44f5080          MOV      r0,#0x1000
00002c  9000              STR      r0,[sp,#0]
;;;609    		GPIO_Init(GPIOH, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  480c              LDR      r0,|L11.100|
000032  f7fffffe          BL       GPIO_Init
;;;610    	}
;;;611    
;;;612    	/* 配置PI6, 禁止 BUSY 作为中断输入口 */
;;;613    	{
;;;614    		EXTI_InitTypeDef   EXTI_InitStructure;
;;;615    
;;;616    		/* Configure EXTI Line6 */
;;;617    		EXTI_InitStructure.EXTI_Line = EXTI_Line6;
000036  2040              MOVS     r0,#0x40
000038  9000              STR      r0,[sp,#0]
;;;618    		EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
00003a  2000              MOVS     r0,#0
00003c  f88d0004          STRB     r0,[sp,#4]
;;;619    		EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
000040  200c              MOVS     r0,#0xc
000042  f88d0005          STRB     r0,[sp,#5]
;;;620    		EXTI_InitStructure.EXTI_LineCmd = DISABLE;
000046  2000              MOVS     r0,#0
000048  f88d0006          STRB     r0,[sp,#6]
;;;621    		EXTI_Init(&EXTI_InitStructure);
00004c  4668              MOV      r0,sp
00004e  f7fffffe          BL       EXTI_Init
;;;622    	}
;;;623    	CONVST_1();					/* 启动转换的GPIO平时设置为高 */
000052  f44f5080          MOV      r0,#0x1000
000056  4903              LDR      r1,|L11.100|
000058  3118              ADDS     r1,r1,#0x18
00005a  8008              STRH     r0,[r1,#0]
;;;624    
;;;625    }
00005c  bd1c              POP      {r2-r4,pc}
;;;626    
                          ENDP

00005e  0000              DCW      0x0000
                  |L11.96|
                          DCD      0x40000c00
                  |L11.100|
                          DCD      0x40021c00

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=1

                  EXTI9_5_IRQHandler PROC
;;;653    #ifndef EXTI9_5_ISR_MOVE_OUT		/* bsp.h 中定义此行，表示本函数移到 stam32f4xx_it.c。 避免重复定义 */
;;;654    void EXTI9_5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;655    {
;;;656    	if (EXTI_GetITStatus(EXTI_Line6) != RESET)
000002  2040              MOVS     r0,#0x40
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b120              CBZ      r0,|L12.20|
;;;657    	{
;;;658    		AD7606_ISR();
00000a  f7fffffe          BL       AD7606_ISR
;;;659    
;;;660    		/* Clear the EXTI line 6 pending bit */
;;;661    		EXTI_ClearITPendingBit(EXTI_Line6);
00000e  2040              MOVS     r0,#0x40
000010  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L12.20|
;;;662    	}
;;;663    }
000014  bd10              POP      {r4,pc}
;;;664    #endif
                          ENDP


                          AREA ||i.bsp_InitAD7606||, CODE, READONLY, ALIGN=2

                  bsp_InitAD7606 PROC
;;;60     */
;;;61     void bsp_InitAD7606(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63     	AD7606_CtrlLinesConfig();
000002  f7fffffe          BL       AD7606_CtrlLinesConfig
;;;64     	AD7606_FSMCConfig();
000006  f7fffffe          BL       AD7606_FSMCConfig
;;;65     
;;;66     	AD7606_SetOS(AD_OS_NO);		/* 无过采样 */
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       AD7606_SetOS
;;;67     	AD7606_SetInputRange(0);	/* 0表示输入量程为正负5V, 1表示正负10V */
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       AD7606_SetInputRange
;;;68     
;;;69     	AD7606_Reset();
000016  f7fffffe          BL       AD7606_Reset
;;;70     
;;;71     	CONVST_1();					/* 启动转换的GPIO平时设置为高 */
00001a  f44f5080          MOV      r0,#0x1000
00001e  4901              LDR      r1,|L13.36|
000020  8008              STRH     r0,[r1,#0]
;;;72     }
000022  bd10              POP      {r4,pc}
;;;73     
                          ENDP

                  |L13.36|
                          DCD      0x40021c18

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tAD7606
                          %        18
                  g_tAdcFifo
                          %        16394

                          AREA ||.data||, DATA, ALIGN=0

                  biaozhi
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp_stm32f4xx\\src\\bsp_ad7606.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_ad7606_c_61266efb____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_ad7606_c_61266efb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_ad7606_c_61266efb____REVSH|
#line 144
|__asm___12_bsp_ad7606_c_61266efb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
